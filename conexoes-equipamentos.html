<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Conex√µes de Equipamentos</title>
  <script src="static/js/demo-banner.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f4f4f4;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 280px;
      background: #222;
      color: #fff;
      padding: 15px;
      overflow-y: auto;
    }

    .sidebar h2 {
      font-size: 1.2em;
      margin-bottom: 15px;
      color: #ffd700;
      text-align: center;
    }

    .equipment-select-container {
      margin-bottom: 20px;
    }

    .equipment-select {
      width: 100%;
      padding: 10px;
      background: #333;
      border: 2px solid #555;
      border-radius: 6px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .equipment-select:hover {
      border-color: #ffd700;
      background: #444;
    }

    .equipment-select:focus {
      outline: none;
      border-color: #ffd700;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
    }

    .equipment-select option {
      background: #333;
      color: #fff;
      padding: 8px;
    }

    .equipment-select option:hover {
      background: #444;
    }

    .equipment-select:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      background: #222;
    }

    .equipment-select:disabled:hover {
      border-color: #555;
      background: #222;
    }

    .equipment-preview {
      margin-top: 10px;
      text-align: center;
      padding: 16px;
      background: #333;
      border-radius: 6px;
      border: 1px solid #555;
    }

    .equipment-preview img {
      width: 80px;
      height: 80px;
      object-fit: contain;
      /* background: #fff; removido para fundo transparente */
      border-radius: 4px;
      margin-bottom: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.10);
    }

    .equipment-preview .name {
      font-size: 12px;
      color: #fff;
      font-weight: bold;
    }

    .equipment-preview.hidden {
      display: none;
    }

    .patch-panel-item {
      background: #2a4a6b;
      border: 2px solid #4a90e2;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .patch-panel-item:hover {
      background: #3a5a7b;
      border-color: #5aa0f2;
      box-shadow: 0 0 8px rgba(74, 144, 226, 0.3);
    }

    .patch-panel-item.selected {
      background: #4a6a8b;
      border-color: #ffd700;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
    }

    .patch-panel-icon {
      font-size: 24px;
      margin-bottom: 5px;
    }
    
    .port-info {
      font-size: 10px;
      color: #666;
      margin-top: 2px;
    }

    .patch-info {
      font-size: 10px;
      color: #a0c0e0;
    }

    .keystone-slot {
      background: rgba(138, 74, 226, 0.15);
      border: 2px solid #8a4ae2;
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 3px;
      min-height: 60px;
    }

    .keystone-slot:hover {
      background: rgba(138, 74, 226, 0.2);
      border-color: #9a5af2;
      box-shadow: 0 0 6px rgba(138, 74, 226, 0.4);
    }

    .keystone-icon {
      font-size: 20px;
      margin-bottom: 2px;
    }

    .grid-cell.keystone {
      background: rgba(138, 74, 226, 0.1);
      border-color: #8a4ae2;
    }

    .grid-cell.keystone:hover {
      background: rgba(138, 74, 226, 0.15);
      border-color: #9a5af2;
    }

    .main-canvas {
      flex: 1;
      position: relative;
      background: url('static/img/blue-print.png');
      background-size: cover;
      overflow: auto;
    }

    .grid-container {
      position: relative; /* Changed from absolute to relative */
      top: 20px;
      left: 20px;
      right: 20px;
      bottom: 20px;
      display: grid;
      gap: 2px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      padding: 2px;
      z-index: 0; /* Ensure grid is behind connections */
    }

    .grid-cell {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      min-height: 100px;
      z-index: 10;
    }

    .grid-cell:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .grid-cell.occupied {
      background: rgba(76, 175, 80, 0.1);
      border-color: #4caf50;
      cursor: grab;
      z-index: 15;
    }

    .grid-cell.occupied:active {
      cursor: grabbing;
    }

    .grid-cell.drag-over {
      background: rgba(255, 215, 0, 0.3) !important;
      border-color: #ffd700 !important;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
      z-index: 20;
    }

    .equipment-slot {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 8px;
      text-align: center;
      user-select: none;
      position: relative;
      z-index: 25;
    }

    .equipment-slot.dragging {
      opacity: 0.5;
      z-index: 30;
    }

    .equipment-slot img {
      max-width: 85px;
      max-height: 85px;
      min-width: 60px;
      min-height: 60px;
      object-fit: contain;
      margin-bottom: 6px;
      border-radius: 6px;
      padding: 3px;
      pointer-events: none;
      box-shadow: 0 3px 8px rgba(0,0,0,0.2);
    }

    /* Tamanhos espec√≠ficos por tipo de equipamento */
    .equipment-slot img[src*="tv"] {
      max-width: 95px;
      max-height: 95px;
    }

    .equipment-slot img[src*="camera"] {
      max-width: 75px;
      max-height: 75px;
    }

    .equipment-slot img[src*="microfone"] {
      max-width: 70px;
      max-height: 70px;
    }

    .equipment-slot img[src*="speaker"] {
      max-width: 80px;
      max-height: 80px;
    }

    .equipment-slot img[src*="amplificador"] {
      max-width: 90px;
      max-height: 90px;
    }

    .equipment-slot img[src*="mixer"] {
      max-width: 85px;
      max-height: 85px;
    }

    .equipment-slot img[src*="projetor"] {
      max-width: 100px;
      max-height: 100px;
    }

    .equipment-slot img[src*="switch"] {
      max-width: 80px;
      max-height: 80px;
    }

    .equipment-slot img[src*="hub"] {
      max-width: 75px;
      max-height: 75px;
    }

    .equipment-slot img[src*="painel"] {
      max-width: 90px;
      max-height: 90px;
    }

    .equipment-slot img[src*="tap"] {
      max-width: 85px;
      max-height: 85px;
    }

    .equipment-slot img[src*="fonte-logitech-tap"] {
      max-width: 70px;
      max-height: 70px;
    }

    .equipment-slot img[src*="meetup"] {
      max-width: 90px;
      max-height: 90px;
    }

    .equipment-slot img[src*="chromebox"] {
      max-width: 70px;
      max-height: 70px;
    }

    .equipment-slot img[src*="pc"] {
      max-width: 75px;
      max-height: 75px;
    }

    /* Classes de tamanho baseadas no tipo de equipamento */
    .equipment-slot.equipment-small img {
      max-width: 65px;
      max-height: 65px;
    }

    .equipment-slot.equipment-medium img {
      max-width: 80px;
      max-height: 80px;
    }

    .equipment-slot.equipment-medium-large img {
      max-width: 90px;
      max-height: 90px;
    }

    .equipment-slot.equipment-large img {
      max-width: 100px;
      max-height: 100px;
    }

    .equipment-slot.equipment-xlarge img {
      max-width: 110px;
      max-height: 110px;
    }

    .equipment-slot .name {
      font-size: 11px;
      color: #fff;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      word-break: break-word;
      line-height: 1.3;
      pointer-events: none;
      text-align: center;
      max-width: 90px;
    }

    .patch-panel-item {
      background: #333;
      border: 2px solid transparent;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .patch-panel-item:hover {
      background: #444;
      border-color: #ffd700;
    }

    .patch-panel-item.selected {
      background: #555;
      border-color: #ffd700;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
    }

    .patch-panel-icon {
      font-size: 24px;
      margin-bottom: 5px;
    }
    
    .port-info {
      font-size: 10px;
      color: #666;
      margin-top: 2px;
    }

    .patch-info {
      font-size: 10px;
      color: #888;
    }

    .keystone-slot {
      background: rgba(138, 74, 226, 0.15);
      border: 2px solid transparent;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .keystone-slot:hover {
      background: rgba(138, 74, 226, 0.2);
      border-color: #ffd700;
    }

    .keystone-slot.selected {
      background: rgba(138, 74, 226, 0.25);
      border-color: #ffd700;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
    }

    .keystone-icon {
      font-size: 24px;
      margin-bottom: 5px;
    }



    .control-group {
      margin-bottom: 15px;
    }

    .control-group label {
      display: block;
      margin-bottom: 5px;
      font-size: 12px;
    }

    .control-group input {
      width: 60px;
      padding: 5px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #333;
      color: #fff;
      text-align: center;
    }

    .control-group button {
      padding: 10px 12px;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      margin-right: 5px;
      margin-bottom: 5px;
      transition: all 0.2s;
      font-weight: 500;
    }

    .control-group button:hover {
      background: #0056b3;
    }

    .control-group button.danger {
      background: #dc3545;
    }

    .control-group button.danger:hover {
      background: #c82333;
    }

    .control-group button.success {
      background: #28a745;
    }

    .control-group button.success:hover {
      background: #218838;
    }

    .control-group button.warning {
      background: #ffc107;
      color: #000;
    }

    .control-group button.warning:hover {
      background: #e0a800;
    }

    .control-group button.active {
      background: #ff4444;
      box-shadow: 0 0 8px rgba(255, 68, 68, 0.5);
    }

    .connection-line {
      position: absolute;
      pointer-events: auto;
      z-index: 5;
      cursor: pointer;
    }

    .connection-line:hover {
      filter: brightness(1.2);
    }

    .connection-line svg {
      width: 100%;
      height: 100%;
    }

    .connection-line path {
      stroke: #ff4444;
      stroke-width: 2;
      stroke-dasharray: 5,5;
      fill: none;
    }

    .connection-line.selected path {
      stroke: #ff0000;
      stroke-width: 3;
      stroke-dasharray: none;
    }

    .connection-label {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ff4444;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 10px;
      color: #333;
      white-space: nowrap;
      pointer-events: none;
      z-index: 6;
    }

    .connection-line.selected .connection-label {
      background: rgba(255, 0, 0, 0.9);
      color: #fff;
      border-color: #ff0000;
    }

    .grid-cell.selected {
      background: rgba(255, 68, 68, 0.3) !important;
      border-color: #ff4444 !important;
      box-shadow: 0 0 8px rgba(255, 68, 68, 0.5);
      z-index: 20;
    }

    .grid-cell.connectable {
      background: rgba(255, 215, 0, 0.2) !important;
      border-color: #ffd700 !important;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
      z-index: 20;
    }

    .grid-cell.removable {
      background: rgba(220, 53, 69, 0.2) !important;
      border-color: #dc3545 !important;
      box-shadow: 0 0 8px rgba(220, 53, 69, 0.5);
      z-index: 20;
    }

    .remove-mode .grid-cell.occupied {
      cursor: pointer;
    }

    .remove-mode .grid-cell.occupied:hover {
      background: rgba(220, 53, 69, 0.3) !important;
      border-color: #dc3545 !important;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: #fff;
      padding: 30px;
      border-radius: 12px;
      min-width: 400px;
      text-align: center;
    }

    .modal h3 {
      margin: 0 0 20px 0;
      color: #333;
    }

    .modal select {
      width: 100%;
      padding: 10px;
      margin-bottom: 20px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .modal button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }

    .modal button.primary {
      background: #007bff;
      color: #fff;
    }

    .modal button.secondary {
      background: #6c757d;
      color: #fff;
    }

    .modal button.danger {
      background: #dc3545;
      color: #fff;
    }

    .modal button.success {
      background: #28a745;
      color: #fff;
    }

    .modal button.info {
      background: #17a2b8;
      color: #fff;
    }

    .modal button:hover {
      opacity: 0.9;
    }

    .modal-steps {
      display: none;
    }

    .modal-steps.active {
      display: block;
    }

    .sala-info {
      background: #f8f9fa;
      border-radius: 6px;
      padding: 15px;
      margin: 15px 0;
      border-left: 4px solid #007bff;
    }

    .sala-info h4 {
      margin: 0 0 10px 0;
      color: #333;
    }

    .sala-info p {
      margin: 5px 0;
      color: #666;
    }

    .layout-status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
    }

    .layout-status.exists {
      background: #d4edda;
      color: #155724;
    }

    .layout-status.new {
      background: #fff3cd;
      color: #856404;
    }

    .status-bar {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 1000;
    }

    .patch-panel-slot {
      background: #2a4a6b;
      border: 2px solid #4a90e2;
      border-radius: 8px;
      padding: 10px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
      min-height: 80px;
    }

    .patch-panel-slot:hover {
      background: #3a5a7b;
      border-color: #5aa0f2;
      box-shadow: 0 0 8px rgba(74, 144, 226, 0.3);
    }

    .grid-cell.patch-panel {
      background: rgba(74, 144, 226, 0.1);
      border-color: #4a90e2;
    }

    .grid-cell.patch-panel:hover {
      background: rgba(74, 144, 226, 0.15);
      border-color: #5aa0f2;
    }

    /* Estilos para elementos de texto */
    .text-element {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      text-align: center;
      user-select: none;
      position: relative;
      z-index: 25;
      cursor: grab;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid #007bff;
      color: #333;
      font-weight: bold;
      font-size: 12px;
      word-break: break-word;
      line-height: 1.3;
      transition: all 0.2s;
    }

    .text-element:hover {
      background: rgba(255, 255, 255, 1);
      border-color: #0056b3;
      box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
    }

    .text-element.dragging {
      opacity: 0.7;
      z-index: 30;
    }

    .text-element.editing {
      background: rgba(255, 255, 255, 1);
      border-color: #28a745;
      box-shadow: 0 0 8px rgba(40, 167, 69, 0.5);
    }

    .grid-cell.text-occupied {
      background: rgba(0, 123, 255, 0.1);
      border-color: #007bff;
      cursor: grab;
      z-index: 15;
    }

    .grid-cell.text-occupied:hover {
      background: rgba(0, 123, 255, 0.15);
      border-color: #0056b3;
    }
  </style>
</head>

<body>
  <div class="container">
    <aside class="sidebar">
      <h2>Equipamentos Dispon√≠veis</h2>
      <div class="equipment-select-container">
        <select class="equipment-select" id="equipmentSelect">
          <option value="">Selecione um equipamento...</option>
        </select>
        
        <div class="equipment-preview hidden" id="equipmentPreview">
          <img id="previewImage" src="" alt="">
          <div class="name" id="previewName"></div>
        </div>
      </div>
      
      <div style="margin-top: 25px; border-top: 1px solid #444; padding-top: 20px;">
        <h3 style="color: #ffd700; margin-bottom: 20px; font-size: 14px; text-align: center;">üéõÔ∏è Controles</h3>
        
        <div class="control-group" style="margin-bottom: 15px;">
          <label style="color: #ccc; font-size: 11px; margin-bottom: 8px; display: block;">Modos de Edi√ß√£o:</label>
          <button id="btnPlaceMode" class="control-group button active" style="width: 100%; margin-bottom: 5px;">
            üì¶ Posicionar
          </button>
          <button id="btnConnectMode" class="control-group button" style="width: 100%; margin-bottom: 5px;">
            üîó Conectar
          </button>
          <button id="btnRemoveMode" class="control-group button" style="width: 100%; margin-bottom: 5px;">
            üóëÔ∏è Remover
          </button>
          <button id="btnTextMode" class="control-group button" style="width: 100%; margin-bottom: 10px;">
            üìù Texto
          </button>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
          <label style="color: #ccc; font-size: 11px; margin-bottom: 8px; display: block;">Carregar Dados:</label>
          <button id="btnLoadRealData" class="control-group button warning" style="width: 100%; margin-bottom: 5px;">
            üîç Dados Reais
          </button>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
          <label style="color: #ccc; font-size: 11px; margin-bottom: 8px; display: block;">Visualiza√ß√£o:</label>
          <div style="color: #fff; font-size: 12px; background: rgba(255,255,255,0.1); padding: 8px; border-radius: 4px; text-align: center;">
            üîó Modo Distribu√≠do Ativo
          </div>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
          <label style="color: #ccc; font-size: 11px; margin-bottom: 8px; display: block;">A√ß√µes:</label>
          <button id="btnSave" class="control-group button success" style="width: 100%; margin-bottom: 5px;">
            üíæ Salvar Layout
          </button>
          <button id="btnClear" class="control-group button danger" style="width: 100%; margin-bottom: 10px;">
            üóëÔ∏è Limpar Tudo
          </button>
        </div>
        
        <div class="control-group" style="margin-top: 20px; border-top: 1px solid #444; padding-top: 15px;">
          <button id="btnSair" class="control-group button" style="width: 100%; background: #6c757d;">
            üîÑ Voltar √† Sele√ß√£o
          </button>
        </div>
      </div>
      
      <!-- Se√ß√£o de Informa√ß√µes -->
      <div style="margin-top: 25px; border-top: 1px solid #444; padding-top: 20px;">
        <h3 style="color: #ffd700; margin-bottom: 20px; font-size: 14px; text-align: center;">‚ÑπÔ∏è Informa√ß√µes</h3>
        
        <div class="control-group" style="margin-bottom: 15px;">
          <label style="color: #ccc; font-size: 11px; margin-bottom: 8px; display: block;">Sala Atual:</label>
          <div id="currentSalaNameDisplay" style="color: #fff; font-size: 12px; background: rgba(255,255,255,0.1); padding: 8px; border-radius: 4px; text-align: center; min-height: 20px;">
            Nenhuma sala selecionada
          </div>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
          <label style="color: #ccc; font-size: 11px; margin-bottom: 8px; display: block;">Grade:</label>
          <div style="color: #fff; font-size: 12px; background: rgba(255,255,255,0.1); padding: 8px; border-radius: 4px; text-align: center;">
            15 x 15 c√©lulas
          </div>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
          <label style="color: #ccc; font-size: 11px; margin-bottom: 8px; display: block;">Status:</label>
          <div id="statusInfo" style="color: #fff; font-size: 11px; background: rgba(255,255,255,0.1); padding: 8px; border-radius: 4px; text-align: center; min-height: 20px;">
            Pronto para editar
          </div>
        </div>
      </div>
    </aside>

    <main class="main-canvas">
      <div class="grid-container grid-layout" id="gridContainer">
        <!-- Grade ser√° criada dinamicamente -->
      </div>
    </main>
  </div>



  <div class="status-bar" id="statusBar">
    Pronto para editar
  </div>

  <!-- Modal inicial para sele√ß√£o de layout -->
  <div class="modal" id="initialModal">
    <div class="modal-content">
      <h3>Gerenciador de Layouts</h3>
      
      <!-- Passo 1: Selecionar sala -->
      <div class="modal-steps active" id="step1">
        <p style="margin-bottom: 20px; color: #666;">Selecione o ambiente/sala para editar ou criar layout:</p>
        <select id="salaSelect">
          <option value="">Carregando salas...</option>
        </select>
        
        <div id="salaInfo" class="sala-info" style="display: none;">
          <h4>Informa√ß√µes da Sala</h4>
          <div id="salaDetails"></div>
          <div id="layoutStatus" style="margin-top: 10px;"></div>
        </div>
        
        <div class="modal-buttons">
          <button class="secondary" id="btnCancel">Cancelar</button>
          <button class="primary" id="btnContinue">Continuar</button>
        </div>
      </div>

      <!-- Passo 2: Confirmar a√ß√£o -->
      <div class="modal-steps" id="step2">
        <div id="confirmInfo"></div>
        <div class="modal-buttons">
          <button class="secondary" id="btnBack">‚Üê Voltar</button>
          <button class="success" id="btnConfirm">Confirmar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal para sele√ß√£o de sala -->
  <div class="modal" id="salaModal">
    <div class="modal-content">
      <h3>Selecionar Sala</h3>
      <select id="salaSelect">
        <option value="">Carregando salas...</option>
      </select>
      <div class="modal-buttons">
        <button class="secondary" id="btnCancelSala">Cancelar</button>
        <button class="primary" id="btnConfirmSala">Confirmar</button>
      </div>
    </div>
  </div>

  <script src="/static/js/equipment-images-map.js?v=1.2"></script>
  <script>
    // Normalizar caminho de imagem (absoluto + /static quando necess√°rio) e aplicar cache busting
    function normalizeImageSrc(url){
      if(!url) return '';
      try {
        let src = url;
        // Se veio com data URL ou blob, mant√©m
        if (src.startsWith('data:') || src.startsWith('blob:')) return src;
        // Remove cache antigo antes de normalizar
        src = src.replace(/[?&](v|r)=[^&#]*/g, '');
        // Garantir absoluto
        if(!src.startsWith('/')) src = '/' + src.replace(/^\/+/, '');
        // Corrigir prefixos /img -> /static/img
        if (src.startsWith('/img/')) src = '/static' + src;
        // For√ßar cache busting
        return cacheBust(src);
      } catch(e){
        return url;
      }
    }
    
    // Evitar cache de imagens no mobile
    function cacheBust(url){ 
      if(!url) return ''; 
      const timestamp = Date.now();
      const random = Math.floor(Math.random() * 1000);
      return url + (url.includes('?') ? '&' : '?') + 'v=' + timestamp + '&r=' + random; 
    }

    // Estado global
    let gridData = {
      rows: 15,
      cols: 20,
      selectedEquipment: null,
      connections: [],
      currentSalaId: null,
      connectionMode: false,
      connectionStart: null,
      removeMode: false,
      textMode: false,
      selectedConnection: null,
      distributedConnections: true, // Novo: modo de visualiza√ß√£o distribu√≠da
      dragState: {
        isDragging: false,
        draggedElement: null,
        originalCell: null,
        originalRow: null,
        originalCol: null,
        dragStartTime: null
      },
      selectedPatchPanel: null
    };

    // Elementos DOM
    const gridContainer = document.getElementById('gridContainer');
    const equipmentSelect = document.getElementById('equipmentSelect');
    const equipmentPreview = document.getElementById('equipmentPreview');
    const previewImage = document.getElementById('previewImage');
    const previewName = document.getElementById('previewName');
    const btnSave = document.getElementById('btnSave');
    const btnClear = document.getElementById('btnClear');
    const btnPlaceMode = document.getElementById('btnPlaceMode');
    const btnConnectMode = document.getElementById('btnConnectMode');
    const btnRemoveMode = document.getElementById('btnRemoveMode');
    const btnTextMode = document.getElementById('btnTextMode');
    const btnLoadRealData = document.getElementById('btnLoadRealData');
    // Bot√£o de modo distribu√≠do removido - modo sempre ativo

    const btnSair = document.getElementById('btnSair');
    const statusBar = document.getElementById('statusBar');
    const statusInfo = document.getElementById('statusInfo');
    const salaModal = document.getElementById('salaModal');
    const salaSelect = document.getElementById('salaSelect');
    const btnCancelSala = document.getElementById('btnCancelSala');
    const btnConfirmSala = document.getElementById('btnConfirmSala');
    
    // Elementos do modal inicial
    const initialModal = document.getElementById('initialModal');
    const step1 = document.getElementById('step1');
    const step2 = document.getElementById('step2');
    const step3 = document.getElementById('step3');
    const salaSelectInitial = document.getElementById('salaSelect');
    const salaInfo = document.getElementById('salaInfo');
    const salaDetails = document.getElementById('salaDetails');
    const layoutStatus = document.getElementById('layoutStatus');
    const confirmInfo = document.getElementById('confirmInfo');
    const btnBack = document.getElementById('btnBack');
    const btnContinue = document.getElementById('btnContinue');
    const btnConfirm = document.getElementById('btnConfirm');
    const btnCancel = document.getElementById('btnCancel');

    // Estado do modal
    let modalState = {
      currentStep: 1,
      action: null, // 'new' ou 'edit'
      selectedSala: null,
      layoutExists: false
    };

    // Fun√ß√£o para carregar equipamentos
    async function loadEquipment() {
      try {
        const response = await fetch('/api/equipamentos-imagens');
        const equipment = await response.json();
        
        // Limpar op√ß√µes existentes (exceto a primeira)
        equipmentSelect.innerHTML = '<option value="">Selecione um equipamento...</option>';
        
        equipment.forEach((src, index) => {
          const name = src.split('/').pop().replace(/\.[a-z]+$/i, '').replace(/-/g, ' ');
          
          const option = document.createElement('option');
          option.value = src;
          option.textContent = name;
          option.dataset.equipment = src;
          
          equipmentSelect.appendChild(option);
        });
        
        // Event listener para mudan√ßa de sele√ß√£o
        equipmentSelect.addEventListener('change', () => {
          const selectedValue = equipmentSelect.value;
          
          if (selectedValue) {
            const name = selectedValue.split('/').pop().replace(/\.[a-z]+$/i, '').replace(/-/g, ' ');
            
            // Atualizar preview
            previewImage.src = selectedValue;
            previewImage.alt = name;
            previewName.textContent = name;
            equipmentPreview.classList.remove('hidden');
            
            // Selecionar equipamento
            gridData.selectedEquipment = selectedValue;
            
            updateStatus(`Equipamento selecionado: ${name}`);
          } else {
            // Esconder preview
            equipmentPreview.classList.add('hidden');
            gridData.selectedEquipment = null;
            updateStatus('Nenhum equipamento selecionado');
          }
        });
        
      } catch (error) {
        console.error('Erro ao carregar equipamentos:', error);
        updateStatus('Erro ao carregar equipamentos');
      }
    }



    // Fun√ß√£o para criar keystone visual
    function createKeystoneVisual(keystone, row, col) {
      console.log(`createKeystoneVisual chamada: keystone=${keystone}, row=${row}, col=${col}`);
      
      const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
      if (!cell) {
        console.error(`C√©lula n√£o encontrada para posi√ß√£o (${row}, ${col})`);
        return;
      }
      
      console.log(`C√©lula encontrada:`, cell);
      
      cell.innerHTML = `
        <div class="equipment-slot keystone-slot">
          <div class="keystone-icon">üîå</div>
          <div class="name">${keystone}</div>
          </div>
      `;
      
      cell.classList.add('occupied', 'keystone');
      cell.dataset.keystone = keystone;
      
      // Torna o keystone arrast√°vel
      const keystoneSlot = cell.querySelector('.keystone-slot');
      if (keystoneSlot) {
        makeEquipmentDraggable(keystoneSlot);
        console.log(`Keystone ${keystone} criado com sucesso na posi√ß√£o (${row}, ${col})`);
      } else {
        console.error(`Keystone slot n√£o encontrado ap√≥s cria√ß√£o`);
      }
    }

    // Fun√ß√£o para criar a grade
    function createGrid() {
      // Salvar dados existentes antes de limpar
      const existingEquipment = [];
      const existingConnections = [...gridData.connections];
      
      // Coletar equipamentos existentes
      document.querySelectorAll('.grid-cell.occupied, .grid-cell.text-occupied').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const img = cell.querySelector('img');
        const name = cell.querySelector('.name').textContent;
        const textElement = cell.querySelector('.text-element');
        const isKeystone = cell.classList.contains('keystone');
        const isText = cell.classList.contains('text-occupied');
        const keystone = isKeystone ? cell.dataset.keystone : null;
        
        if (isText) {
          // √â um elemento de texto
          existingEquipment.push({
            row: row,
            col: col,
            type: 'text',
            content: textElement ? textElement.textContent.trim() : '',
            isText: true
          });
        } else {
          // √â um equipamento
          existingEquipment.push({
            row: row,
            col: col,
            src: img ? img.src : null,
            name: name ? name.textContent : '',
            isKeystone: isKeystone,
            keystone: keystone,
            type: 'equipment'
          });
        }
      });
      
      // Limpar container
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `repeat(${gridData.cols}, 1fr)`;
      gridContainer.style.gridTemplateRows = `repeat(${gridData.rows}, 1fr)`;
      
      // Criar SVG de conex√µes
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.id = 'svg-connections';
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '5';
      
      // Adicionar defini√ß√µes SVG
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.id = 'arrowhead';
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '7');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3.5');
      marker.setAttribute('orient', 'auto');
      
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
      polygon.setAttribute('fill', '#007bff');
      
      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(defs);
      gridContainer.appendChild(svg);
      
      gridData.cells = [];
      
      for (let row = 0; row < gridData.rows; row++) {
        for (let col = 0; col < gridData.cols; col++) {
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.dataset.index = gridData.cells.length;
          
          // Evento de clique simples
          cell.addEventListener('click', (e) => {
            // Se est√° arrastando, ignora clique
            if (gridData.dragState.isDragging) {
              return;
            }
            
            // Se acabou de arrastar, ignora clique por um tempo
            if (gridData.dragState.dragStartTime && (Date.now() - gridData.dragState.dragStartTime) < 300) {
              return;
            }
            
            handleCellClick(cell, row, col);
          });
          
          cell.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            handleCellRightClick(cell, row, col);
          });
          
          // Eventos de drag and drop
          cell.addEventListener('dragover', (e) => handleDragOver(e, cell));
          cell.addEventListener('dragenter', (e) => handleDragEnter(e, cell));
          cell.addEventListener('dragleave', (e) => handleDragLeave(e, cell));
          cell.addEventListener('drop', (e) => handleDrop(e, cell, row, col));
          
          gridContainer.appendChild(cell);
          gridData.cells.push({
            element: cell,
            row: row,
            col: col,
            equipment: null,
            equipmentName: null
          });
        }
      }
      
      // Restaurar equipamentos que ainda cabem na nova grade
      let restoredEquipment = 0;
      existingEquipment.forEach(item => {
        if (item.row < gridData.rows && item.col < gridData.cols) {
          const cell = document.querySelector(`[data-row="${item.row}"][data-col="${item.col}"]`);
          if (cell) {
            if (item.isText) {
              // Restaurar elemento de texto
              cell.innerHTML = `
                <div class="text-element">
                  ${item.content || ''}
                </div>
              `;
              cell.classList.add('text-occupied');
              
              // Torna o texto arrast√°vel
              const textElement = cell.querySelector('.text-element');
              if (textElement) {
                makeTextDraggable(textElement);
              }
            } else if (item.isKeystone) {
              // Restaurar keystone
              cell.innerHTML = `
                <div class="equipment-slot keystone-slot">
                  <div class="keystone-icon">üîå</div>
                  <div class="name">${item.name}</div>
                </div>
              `;
              cell.classList.add('occupied', 'keystone');
              cell.dataset.keystone = item.keystone;
            } else {
              // Restaurar equipamento normal
              cell.innerHTML = `
                <div class="equipment-slot">
                  <img src="${cacheBust(item.src ? (item.src.startsWith('/') ? item.src : '/' + item.src.replace(/^\/+/, '')) : '')}" alt="${item.name}">
                  <div class="name">${item.name}</div>
                </div>
              `;
              cell.classList.add('occupied');
            }
            
            // Torna o equipamento arrast√°vel (se n√£o for texto)
            if (!item.isText) {
              const equipmentSlot = cell.querySelector('.equipment-slot');
              if (equipmentSlot) {
                makeEquipmentDraggable(equipmentSlot);
              }
            }
            restoredEquipment++;
          }
        }
      });
      
      // Restaurar conex√µes que ainda s√£o v√°lidas
      const validConnections = existingConnections.filter(conn => {
        const fromValid = conn.from.row < gridData.rows && conn.from.col < gridData.cols;
        const toValid = conn.to.row < gridData.rows && conn.to.col < gridData.cols;
        return fromValid && toValid;
      });
      
      gridData.connections = validConnections;
      
      // Redesenhar conex√µes v√°lidas
      if (gridData.connections.length > 0) {
        redrawAllConnections();
      }
      
      // Mostrar aviso se equipamentos ou conex√µes foram perdidos
      const lostEquipment = existingEquipment.length - restoredEquipment;
      const lostConnections = existingConnections.length - validConnections.length;
      
      if (lostEquipment > 0 || lostConnections > 0) {
        let warningMessage = '';
        if (lostEquipment > 0) {
          warningMessage += `${lostEquipment} equipamento(s) perdido(s) `;
        }
        if (lostConnections > 0) {
          warningMessage += `${lostConnections} conex√£o(√µes) perdida(s) `;
        }
        warningMessage += 'devido √† redu√ß√£o da grade';
        
        // Mostrar alerta tempor√°rio
        setTimeout(() => {
          alert(`‚ö†Ô∏è ${warningMessage}\n\nEquipamentos e conex√µes fora dos limites da nova grade foram removidos.`);
        }, 100);
      }
    }

    // Fun√ß√£o para tornar equipamento arrast√°vel
    function makeEquipmentDraggable(equipmentSlot) {
      equipmentSlot.draggable = true;
      
      equipmentSlot.addEventListener('dragstart', (e) => {
        if (gridData.connectionMode || gridData.removeMode) {
          e.preventDefault();
          return;
        }
        
        gridData.dragState.isDragging = true;
        gridData.dragState.draggedElement = equipmentSlot;
        gridData.dragState.originalCell = equipmentSlot.closest('.grid-cell');
        gridData.dragState.originalRow = parseInt(gridData.dragState.originalCell.dataset.row);
        gridData.dragState.originalCol = parseInt(gridData.dragState.originalCell.dataset.col);
        gridData.dragState.dragStartTime = Date.now();
        
        equipmentSlot.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', 'equipment');
        
        console.log('Iniciando arrasto:', gridData.dragState.originalRow, gridData.dragState.originalCol);
      });
      
      equipmentSlot.addEventListener('dragend', (e) => {
        gridData.dragState.isDragging = false;
        gridData.dragState.draggedElement = null;
        gridData.dragState.originalCell = null;
        gridData.dragState.originalRow = null;
        gridData.dragState.originalCol = null;
        gridData.dragState.dragStartTime = null;
        
        equipmentSlot.classList.remove('dragging');
        
        // Remove destaque de todas as c√©lulas
        document.querySelectorAll('.grid-cell.drag-over').forEach(cell => {
          cell.classList.remove('drag-over');
        });
        
        console.log('Finalizando arrasto');
      });
    }

    // Fun√ß√£o para lidar com clique na c√©lula - otimizada
    function handleCellClick(cell, row, col) {
      // Verifica√ß√µes r√°pidas primeiro
      if (gridData.removeMode) {
        handleRemoveClick(cell, row, col);
        return;
      }
      
      if (gridData.connectionMode) {
        handleConnectionClick(cell, row, col);
        return;
      }
      
      if (gridData.textMode) {
        handleTextClick(cell, row, col);
        return;
      }
      
      // Modo posicionamento
      handlePlacementClick(cell, cell.dataset.index);
    }

    // Fun√ß√£o para determinar classe de tamanho baseada no nome do equipamento
    function getEquipmentSizeClass(equipmentName) {
      const name = equipmentName.toLowerCase();
      
      // TVs - maiores
      if (name.includes('tv') || name.includes('tela') || name.includes('monitor')) {
        return 'equipment-large';
      }
      
      // Projetores - muito grandes
      if (name.includes('projetor') || name.includes('projector')) {
        return 'equipment-xlarge';
      }
      
      // Amplificadores - grandes
      if (name.includes('amplificador') || name.includes('amplifier')) {
        return 'equipment-large';
      }
      
      // Pain√©is e TAPs - m√©dios-grandes
      if (name.includes('painel') || name.includes('panel') || name.includes('tap')) {
        return 'equipment-medium-large';
      }
      
      // Meetups - m√©dios-grandes
      if (name.includes('meetup')) {
        return 'equipment-medium-large';
      }
      
      // C√¢meras - m√©dias
      if (name.includes('camera') || name.includes('cam')) {
        return 'equipment-medium';
      }
      
      // Speakers - m√©dios
      if (name.includes('speaker') || name.includes('caixa')) {
        return 'equipment-medium';
      }
      
      // Switches e Hubs - m√©dios
      if (name.includes('switch') || name.includes('hub')) {
        return 'equipment-medium';
      }
      
      // Microfones - pequenos
      if (name.includes('microfone') || name.includes('mic')) {
        return 'equipment-small';
      }
      
      // Chromebox - m√©dio (maior que antes)
      if (name.includes('chromebox')) {
        return 'equipment-medium';
      }
      
      // PC, Dongle - pequenos
      if (name.includes('pc') || name.includes('dongle')) {
        return 'equipment-small';
      }
      
      // POE, Mixers - m√©dios
      if (name.includes('poe') || name.includes('mixer')) {
        return 'equipment-medium';
      }
      
      // Padr√£o - m√©dio
      return 'equipment-medium';
    }

    // Fun√ß√£o para lidar com clique para posicionamento - otimizada
    function handlePlacementClick(cell, cellIndex) {
      if (!gridData.selectedEquipment) {
        updateStatus('Selecione um equipamento primeiro!');
        return;
      }
      
      const cellData = gridData.cells[cellIndex];
      
      // Se √© um patch panel selecionado
      if (gridData.selectedEquipment === 'patch-panel' && gridData.selectedPatchPanel) {
        const panel = gridData.selectedPatchPanel;
        
        // Criar patch panel visual
        cell.innerHTML = `
          <div class="equipment-slot patch-panel-slot">
            <div class="patch-panel-icon">üì°</div>
            <div class="name">${panel.nome}</div>
            <div class="patch-info">${panel.num_portas} portas</div>
          </div>
        `;
        
        cell.classList.add('occupied', 'patch-panel');
        cellData.equipment = 'patch-panel';
        cellData.equipmentName = panel.nome;
        cellData.patchPanelId = panel.id;
        
        // Torna o patch panel arrast√°vel
        const patchPanelSlot = cell.querySelector('.patch-panel-slot');
        makeEquipmentDraggable(patchPanelSlot);
        
        // Carregar keystones ocupados automaticamente
        loadKeystonesForPanel(panel.id, cellIndex);
        
        updateStatus(`Patch Panel ${panel.nome} posicionado`);
        return;
      }
      
      // Equipamento normal
      const name = gridData.selectedEquipment.split('/').pop().replace(/\.[a-z]+$/i, '').replace(/-/g, ' ');
      const sizeClass = getEquipmentSizeClass(name);
      
      // Atualiza c√©lula diretamente
      cell.innerHTML = `
        <div class="equipment-slot ${sizeClass}">
          <img src="${cacheBust(gridData.selectedEquipment ? (gridData.selectedEquipment.startsWith('/') ? gridData.selectedEquipment : '/' + gridData.selectedEquipment.replace(/^\/+/, '')) : '')}" alt="${name}">
          <div class="name">${name}</div>
        </div>
      `;
      
      cell.classList.add('occupied');
      cellData.equipment = gridData.selectedEquipment;
      cellData.equipmentName = name;
      
      // Torna o equipamento arrast√°vel
      const equipmentSlot = cell.querySelector('.equipment-slot');
      makeEquipmentDraggable(equipmentSlot);
      
      updateStatus(`Equipamento ${name} posicionado`);
    }



    // Fun√ß√£o para lidar com clique para conex√µes - otimizada
    function handleConnectionClick(cell, row, col) {
      if (!cell.classList.contains('occupied')) {
        updateStatus('Selecione uma c√©lula com equipamento para conectar!');
        return;
      }

      if (!gridData.connectionStart) {
        // Primeira sele√ß√£o
        gridData.connectionStart = { cell, row, col };
        cell.classList.add('selected');
        highlightConnectableCells(cell);
        updateStatus('Selecione o segundo equipamento para conectar');
      } else if (gridData.connectionStart.cell === cell) {
        // Desselecionar
        gridData.connectionStart = null;
        cell.classList.remove('selected');
        clearConnectableHighlights();
        updateStatus('Conex√£o cancelada');
      } else {
        // Segunda sele√ß√£o - criar conex√£o
        const startCell = gridData.connectionStart.cell;
        startCell.classList.remove('selected');
        clearConnectableHighlights();
        
        createConnection(gridData.connectionStart, { cell, row, col });
        gridData.connectionStart = null;
      }
    }

    // Fun√ß√£o para lidar com clique para remo√ß√£o - otimizada
    function handleRemoveClick(cell, row, col) {
      if (cell.classList.contains('occupied')) {
        const name = cell.querySelector('.name').textContent;
        if (confirm(`Remover equipamento "${name}" desta posi√ß√£o?`)) {
          removeEquipment(cell, row, col);
        }
      } else if (cell.classList.contains('text-occupied')) {
        const textElement = cell.querySelector('.text-element');
        const text = textElement ? textElement.textContent.trim() : 'Texto';
        if (confirm(`Remover texto "${text}" desta posi√ß√£o?`)) {
          cell.innerHTML = '';
          cell.classList.remove('text-occupied');
          updateStatus(`Texto "${text}" removido`);
        }
      }
    }

    // Remover equipamento
    function removeEquipment(cell, row, col) {
      const name = cell.querySelector('.name').textContent;
      
      // Remove equipamento da c√©lula
      cell.innerHTML = '';
      cell.classList.remove('occupied', 'keystone', 'text-occupied');
      delete cell.dataset.keystone;
      
      // Remove conex√µes relacionadas
      const connectionsToRemove = gridData.connections.filter(conn => 
        (conn.from.row === row && conn.from.col === col) ||
        (conn.to.row === row && conn.to.col === col)
      );
      
      connectionsToRemove.forEach(conn => {
        removeConnection(conn.id);
      });
      
      updateStatus(`Equipamento "${name}" removido${connectionsToRemove.length > 0 ? ` e ${connectionsToRemove.length} conex√£o(√µes) removida(s)` : ''}`);
    }

    // Remover conex√£o
    function removeConnection(connectionId) {
      const connection = gridData.connections.find(conn => conn.id === connectionId);
      if (connection) {
        // Remove do array
        gridData.connections = gridData.connections.filter(conn => conn.id !== connectionId);
        
        // Remove elementos visuais do SVG
        const svg = document.getElementById('svg-connections');
        const path = svg.querySelector(`path[data-connection-id="${connectionId}"]`);
        if (path) {
          // Remove o path e os elementos relacionados (texto e fundo)
          const pathIndex = Array.from(svg.children).indexOf(path);
          if (pathIndex !== -1) {
            // Remove o path
            svg.removeChild(path);
            
            // Remove o texto e fundo relacionados (se existirem)
            const textElements = svg.querySelectorAll('text');
            const rectElements = svg.querySelectorAll('rect');
            
            // Remove elementos pr√≥ximos que podem ser o texto e fundo desta conex√£o
            for (let i = 0; i < textElements.length; i++) {
              const text = textElements[i];
              if (text.textContent === connection.cableInfo) {
                svg.removeChild(text);
                break;
              }
            }
            
            for (let i = 0; i < rectElements.length; i++) {
              const rect = rectElements[i];
              if (rect.getAttribute('fill') === 'rgba(255, 255, 255, 0.9)') {
                svg.removeChild(rect);
                break;
              }
            }
          }
        }
        
        updateStatus(`Conex√£o "${connection.cableInfo}" removida`);
      }
    }

    // Fun√ß√£o para destacar c√©lulas conect√°veis - otimizada
    function highlightConnectableCells(excludeCell) {
      const cells = document.querySelectorAll('.grid-cell.occupied');
      for (let i = 0; i < cells.length; i++) {
        const cell = cells[i];
        if (cell !== excludeCell) {
          cell.classList.add('connectable');
        }
      }
    }

    // Fun√ß√£o para limpar destaque de c√©lulas conect√°veis - otimizada
    function clearConnectableHighlights() {
      const cells = document.querySelectorAll('.grid-cell.connectable');
      for (let i = 0; i < cells.length; i++) {
        cells[i].classList.remove('connectable');
      }
    }

    // Criar conex√£o
    function createConnection(from, to) {
      const fromName = from.cell.querySelector('.name').textContent;
      const toName = to.cell.querySelector('.name').textContent;
      
      // Solicitar informa√ß√µes do cabo
      const cableInfo = prompt(`Conex√£o: ${fromName} ‚Üí ${toName}\n\nDigite as informa√ß√µes do cabo (ex: HDMI-001, USB-002):`);
      
      if (cableInfo === null) {
        updateStatus('Conex√£o cancelada');
        return;
      }

      const connection = {
        from: { row: from.row, col: from.col },
        to: { row: to.row, col: to.col },
        fromName: fromName,
        toName: toName,
        cableInfo: cableInfo,
        id: `manual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      };

      console.log(`üîó Criando conex√£o manual:`);
      console.log(`  - FROM: ${fromName} (${from.row},${from.col})`);
      console.log(`  - TO: ${toName} (${to.row},${to.col})`);
      console.log(`  - CableInfo: ${cableInfo}`);
      console.log(`  - Connection object:`, connection);

      // Verificar se a conex√£o j√° existe antes de adicionar
      if (!connectionExists(connection, gridData.connections)) {
        gridData.connections.push(connection);
        console.log(`‚úÖ Conex√£o adicionada ao array. Total: ${gridData.connections.length}`);
        drawConnection(connection);
        updateStatus(`Conex√£o criada: ${fromName} ‚Üí ${toName} (${cableInfo})`);
      } else {
        console.log(`‚ö†Ô∏è Conex√£o duplicada ignorada`);
        updateStatus(`Conex√£o duplicada ignorada: ${fromName} ‚Üí ${toName} (${cableInfo})`);
      }
    }

    // Redesenhar todas as conex√µes - otimizada
    function redrawAllConnections() {
      console.log('Redesenhando todas as conex√µes...');
      console.log('Total de conex√µes:', gridData.connections.length);
      
      // Verificar se o SVG existe
      const svg = document.getElementById('svg-connections');
      if (!svg) {
        console.warn('SVG de conex√µes n√£o encontrado');
        return;
      }
      
      const defs = svg.querySelector('defs');
      if (!defs) {
        console.warn('Defini√ß√µes SVG n√£o encontradas');
        return;
      }
      
      // Remove todos os elementos exceto defs
      while (svg.firstChild) {
        svg.removeChild(svg.firstChild);
      }
      
      // Readiciona as defini√ß√µes
      svg.appendChild(defs);
      
      // Verificar se h√° equipamentos posicionados antes de desenhar conex√µes
      const occupiedCells = document.querySelectorAll('.grid-cell.occupied');
      console.log('C√©lulas ocupadas encontradas:', occupiedCells.length);
      
      if (occupiedCells.length === 0) {
        console.warn('Nenhuma c√©lula ocupada encontrada. Aguardando posicionamento de equipamentos...');
        return;
      }
      
      // Redesenha todas as conex√µes
      const connections = gridData.connections;
      let drawnConnections = 0;
      
      console.log(`üîÑ Redesenhando ${connections.length} conex√µes...`);
      
      for (let i = 0; i < connections.length; i++) {
        const connection = connections[i];
        console.log(`\n--- Redesenhando conex√£o ${i + 1}/${connections.length} ---`);
        console.log(`  - ID: ${connection.id}`);
        console.log(`  - FROM: ${connection.fromName} (${connection.from.row},${connection.from.col})`);
        console.log(`  - TO: ${connection.toName} (${connection.to.row},${connection.to.col})`);
        console.log(`  - CableInfo: ${connection.cableInfo}`);
        
        try {
          drawConnection(connection);
          drawnConnections++;
          console.log(`  - ‚úÖ Conex√£o redesenhada com sucesso`);
        } catch (error) {
          console.error(`  - ‚ùå Erro ao redesenhar conex√£o ${i}:`, error);
        }
      }
      
      console.log(`‚úÖ ${drawnConnections}/${connections.length} conex√µes redesenhadas com sucesso`);
    }

    // Fun√ß√£o para determinar cor do cabo baseado no tipo
    function getCableColor(cableInfo) {
      const info = cableInfo.toLowerCase();
      
      // Ethernet / RJ45 / CAT
      if (info.includes('ethernet') || info.includes('rj45') || info.includes('cat') || 
          info.includes('eth') || info.includes('lan') || info.includes('network')) {
        return '#4CAF50'; // Verde
      }
      
      // HDMI
      if (info.includes('hdmi')) {
        return '#2196F3'; // Azul
      }
      
      // USB
      if (info.includes('usb')) {
        return '#FF9800'; // Laranja
      }
      
      // VGA
      if (info.includes('vga')) {
        return '#9C27B0'; // Roxo
      }
      
      // DisplayPort
      if (info.includes('displayport') || info.includes('dp')) {
        return '#00BCD4'; // Ciano
      }
      
      // DVI
      if (info.includes('dvi')) {
        return '#795548'; // Marrom
      }
      
      // Audio / XLR / TRS
      if (info.includes('audio') || info.includes('xlr') || info.includes('trs') || 
          info.includes('jack') || info.includes('mic') || info.includes('speaker')) {
        return '#E91E63'; // Rosa
      }
      
      // Power / Alimenta√ß√£o
      if (info.includes('power') || info.includes('alimentacao') || info.includes('energia') ||
          info.includes('poe') || info.includes('ac') || info.includes('dc')) {
        return '#FF5722'; // Vermelho escuro
      }
      
      // Serial / RS232 / RS485
      if (info.includes('serial') || info.includes('rs232') || info.includes('rs485') ||
          info.includes('com') || info.includes('modbus')) {
        return '#607D8B'; // Azul acinzentado
      }
      
      // Padr√£o - cinza
      return '#9E9E9E';
    }

    // Fun√ß√£o para calcular pontos de conex√£o distribu√≠dos
    function calculateDistributedConnectionPoints(fromCell, toCell, connectionIndex, totalConnections) {
      // Usar offsetLeft/offsetTop para coordenadas relativas ao container
      const centerX1 = fromCell.offsetLeft + fromCell.offsetWidth / 2;
      const centerY1 = fromCell.offsetTop + fromCell.offsetHeight / 2;
      const centerX2 = toCell.offsetLeft + toCell.offsetWidth / 2;
      const centerY2 = toCell.offsetTop + toCell.offsetHeight / 2;

      console.log(`Centros: (${centerX1},${centerY1}) -> (${centerX2},${centerY2})`);
      console.log(`  - fromCell (origem): (${centerX1},${centerY1})`);
      console.log(`  - toCell (destino): (${centerX2},${centerY2})`);
      console.log(`  - fromCell.offsetLeft: ${fromCell.offsetLeft}, fromCell.offsetTop: ${fromCell.offsetTop}`);
      console.log(`  - toCell.offsetLeft: ${toCell.offsetLeft}, toCell.offsetTop: ${toCell.offsetTop}`);

      // Se h√° apenas uma conex√£o, usar pontos centrais
      if (totalConnections <= 1) {
        console.log(`  - Conex√£o √∫nica: usando pontos centrais`);
        console.log(`  - x1,y1 (origem): (${centerX1},${centerY1}) - deve ser fromCell`);
        console.log(`  - x2,y2 (destino): (${centerX2},${centerY2}) - deve ser toCell`);
        
        return {
          x1: centerX1,
          y1: centerY1,
          x2: centerX2,
          y2: centerY2
        };
      }

      // Calcular offset baseado no n√∫mero de conex√µes
      const maxOffset = Math.min(fromCell.offsetWidth, fromCell.offsetHeight) * 0.2; // 20% do tamanho da c√©lula
      const offset = (maxOffset * (connectionIndex - (totalConnections - 1) / 2)) / totalConnections;

      // Calcular dire√ß√£o da conex√£o
      const dx = centerX2 - centerX1;
      const dy = centerY2 - centerY1;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance === 0) {
        return {
          x1: centerX1,
          y1: centerY1,
          x2: centerX2,
          y2: centerY2
        };
      }

      // Calcular vetor perpendicular para distribuir as conex√µes
      const perpX = -dy / distance;
      const perpY = dx / distance;

            // Aplicar offset perpendicular
      const x1 = centerX1 + perpX * offset;
      const y1 = centerY1 + perpY * offset;
      const x2 = centerX2 + perpX * offset;
      const y2 = centerY2 + perpY * offset;
      
      console.log(`  Modo distribu√≠do: ${gridData.distributedConnections}, Total conex√µes: ${totalConnections}, √çndice: ${connectionIndex}`);
      console.log(`  Pontos distribu√≠dos: (${x1},${y1}) -> (${x2},${y2})`);
      console.log(`  - x1,y1 (origem): (${x1},${y1}) - deve ser fromCell`);
      console.log(`  - x2,y2 (destino): (${x2},${y2}) - deve ser toCell`);
      console.log(`  - centerX1,centerY1 (fromCell): (${centerX1},${centerY1})`);
      console.log(`  - centerX2,centerY2 (toCell): (${centerX2},${centerY2})`);

      return { x1, y1, x2, y2 };
    }

    // Fun√ß√£o para desenhar conex√£o - otimizada com distribui√ß√£o
    function drawConnection(connection) {
      console.log(`drawConnection chamada para: ${connection.fromName} ‚Üí ${connection.toName}`);
      console.log('Dados da conex√£o:', connection);
      console.log(`  - FROM: row=${connection.from.row}, col=${connection.from.col}, nome=${connection.fromName}`);
      console.log(`  - TO: row=${connection.to.row}, col=${connection.to.col}, nome=${connection.toName}`);
      
      // Buscar c√©lulas na ordem CORRETA: origem -> destino
      const fromCell = document.querySelector(`[data-row="${connection.from.row}"][data-col="${connection.from.col}"]`);
      const toCell = document.querySelector(`[data-row="${connection.to.row}"][data-col="${connection.to.col}"]`);
      
      console.log('C√©lula de origem encontrada:', fromCell);
      console.log('C√©lula de destino encontrada:', toCell);
      
      if (!fromCell || !toCell) {
        console.warn('C√©lulas de conex√£o n√£o encontradas:', connection);
        if (!fromCell) console.warn(`  - C√©lula origem n√£o encontrada: row=${connection.from.row}, col=${connection.from.col}`);
        if (!toCell) console.warn(`  - C√©lula destino n√£o encontrada: row=${connection.to.row}, col=${connection.to.col}`);
        return;
      }

      // Verificar se as c√©lulas cont√™m os equipamentos corretos
      const fromName = fromCell.querySelector('.name')?.textContent || 'Sem nome';
      const toName = toCell.querySelector('.name')?.textContent || 'Sem nome';
      
      console.log(`Verifica√ß√£o de nomes:`);
      console.log(`  - C√©lula origem (${connection.from.row},${connection.from.col}): "${fromName}"`);
      console.log(`  - C√©lula destino (${connection.to.row},${connection.to.col}): "${toName}"`);
      console.log(`  - Esperado origem: "${connection.fromName}"`);
      console.log(`  - Esperado destino: "${connection.toName}"`);
      
      // Verificar se os nomes correspondem (com toler√¢ncia para varia√ß√µes)
      const fromNameMatch = fromName.toLowerCase().includes(connection.fromName.toLowerCase()) || 
                           connection.fromName.toLowerCase().includes(fromName.toLowerCase());
      const toNameMatch = toName.toLowerCase().includes(connection.toName.toLowerCase()) || 
                         connection.toName.toLowerCase().includes(toName.toLowerCase());
      
      if (!fromNameMatch || !toNameMatch) {
        console.warn(`‚ö†Ô∏è Nomes n√£o correspondem:`);
        if (!fromNameMatch) console.warn(`  - Origem: esperado "${connection.fromName}", encontrado "${fromName}"`);
        if (!toNameMatch) console.warn(`  - Destino: esperado "${connection.toName}", encontrado "${toName}"`);
        console.warn(`  - Continuando mesmo assim...`);
      }

      // Contar conex√µes entre os mesmos equipamentos (incluindo a atual)
      const sameConnections = gridData.connections.filter(conn => 
        (conn.from.row === connection.from.row && conn.from.col === connection.from.col &&
         conn.to.row === connection.to.row && conn.to.col === connection.to.col) ||
        (conn.from.row === connection.to.row && conn.from.col === connection.to.col &&
         conn.to.row === connection.from.row && conn.to.col === connection.from.col)
      );

      // Encontrar √≠ndice desta conex√£o espec√≠fica
      const connectionIndex = sameConnections.findIndex(conn => conn.id === connection.id);
      const totalConnections = sameConnections.length;

      console.log(`üîç AN√ÅLISE DE CONEX√ïES M√öLTIPLAS:`);
      console.log(`  - Conex√£o atual ID: ${connection.id}`);
      console.log(`  - CableInfo: ${connection.cableInfo}`);
      console.log(`  - Total de conex√µes entre os mesmos equipamentos: ${totalConnections}`);
      console.log(`  - √çndice desta conex√£o: ${connectionIndex + 1}`);
      console.log(`  - Todas as conex√µes no gridData: ${gridData.connections.length}`);
      
      // Debug: mostrar todas as conex√µes entre os mesmos equipamentos
      sameConnections.forEach((conn, idx) => {
        console.log(`    ${idx + 1}. ID: ${conn.id}, CableInfo: ${conn.cableInfo}, FROM: ${conn.fromName}, TO: ${conn.toName}`);
      });

      console.log(`Conex√£o ${connectionIndex + 1} de ${totalConnections} entre os mesmos equipamentos`);
      console.log('Modo distribu√≠do ativo:', gridData.distributedConnections);
      console.log('Todas as conex√µes:', gridData.connections);
      console.log('Conex√µes entre os mesmos equipamentos:', sameConnections);

      // Calcular pontos distribu√≠dos - IMPORTANTE: fromCell √© origem, toCell √© destino
      console.log(`üîç Calculando pontos para conex√£o:`);
      console.log(`  - fromCell (origem): ${connection.fromName} em (${connection.from.row},${connection.from.col})`);
      console.log(`  - toCell (destino): ${connection.toName} em (${connection.to.row},${connection.to.col})`);
      
      const points = calculateDistributedConnectionPoints(fromCell, toCell, connectionIndex + 1, totalConnections);

      console.log(`Coordenadas da conex√£o distribu√≠da: (${points.x1},${points.y1}) ‚Üí (${points.x2},${points.y2})`);
      console.log(`  - Ponto 1 (origem): (${points.x1},${points.y1}) - Equipamento: ${connection.fromName}`);
      console.log(`  - Ponto 2 (destino): (${points.x2},${points.y2}) - Equipamento: ${connection.toName}`);

      // Usar o SVG dentro do grid-container
      const svg = document.getElementById('svg-connections');
      if (!svg) {
        console.warn('SVG de conex√µes n√£o encontrado');
        return;
      }
      
      console.log('SVG encontrado, criando path...');
      
      // Determinar cor do cabo
      const cableColor = getCableColor(connection.cableInfo);
      
      // Criar path para a conex√£o com curva suave se houver m√∫ltiplas conex√µes
      let pathData;
      if (totalConnections > 1 && gridData.distributedConnections) {
        // Usar linha reta para conex√µes m√∫ltiplas no modo distribu√≠do
        pathData = `M${points.x1},${points.y1} L${points.x2},${points.y2}`;
        console.log(`Modo distribu√≠do: usando linha reta para ${totalConnections} conex√µes`);
        console.log(`  - Path SVG: M${points.x1},${points.y1} L${points.x2},${points.y2}`);
        console.log(`  - Dire√ß√£o: (${points.x1},${points.y1}) ‚Üí (${points.x2},${points.y2})`);
      } else {
        // Linha reta para conex√£o √∫nica ou modo agrupado
        pathData = `M${points.x1},${points.y1} L${points.x2},${points.y2}`;
        console.log(`Modo agrupado ou conex√£o √∫nica: usando linha reta`);
        console.log(`  - Path SVG: M${points.x1},${points.y1} L${points.x2},${points.y2}`);
        console.log(`  - Dire√ß√£o: (${points.x1},${points.y1}) ‚Üí (${points.x2},${points.y2})`);
      }

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', pathData);
      path.setAttribute('stroke', cableColor);
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-dasharray', '5,5');
      path.setAttribute('fill', 'none');
      path.dataset.connectionId = connection.id;
      
      // Adicionar evento de clique para remover conex√£o
      path.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm(`Remover conex√£o "${connection.cableInfo}"?`)) {
          removeConnection(connection.id);
        }
      });

      // Adicionar evento de hover para destacar
      path.addEventListener('mouseenter', () => {
        if (!gridData.removeMode) {
          path.setAttribute('stroke', '#ff0000');
          path.setAttribute('stroke-width', '3');
          path.setAttribute('stroke-dasharray', 'none');
        }
      });

      path.addEventListener('mouseleave', () => {
        path.setAttribute('stroke', cableColor);
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-dasharray', '5,5');
      });

      svg.appendChild(path);
      console.log('Path adicionado ao SVG');

      // Criar label do cabo como elemento SVG com posicionamento inteligente
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      
      // Calcular posi√ß√£o do texto com offset para evitar sobreposi√ß√£o
      let textX = (points.x1 + points.x2) / 2;
      let textY = (points.y1 + points.y2) / 2 - 5;
      
      console.log(`üìù Posicionando texto do cabo:`);
      console.log(`  - Posi√ß√£o central: (${textX},${textY})`);
      console.log(`  - Texto: "${connection.cableInfo}"`);
      
      // Se h√° m√∫ltiplas conex√µes e modo distribu√≠do, ajustar posi√ß√£o do texto
      if (totalConnections > 1 && gridData.distributedConnections) {
        const textOffset = 15 * (connectionIndex - (totalConnections - 1) / 2);
        textY += textOffset;
        console.log(`  - Offset aplicado: ${textOffset}, nova posi√ß√£o Y: ${textY}`);
      }
      
      text.setAttribute('x', textX);
      text.setAttribute('y', textY);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('font-size', '10px');
      text.setAttribute('font-family', 'Arial, sans-serif');
      text.setAttribute('fill', '#333');
      text.setAttribute('pointer-events', 'none');
      text.textContent = connection.cableInfo;
      
      // Adicionar fundo ao texto
      const textBBox = text.getBBox();
      const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      background.setAttribute('x', textBBox.x - 2);
      background.setAttribute('y', textBBox.y - 1);
      background.setAttribute('width', textBBox.width + 4);
      background.setAttribute('height', textBBox.height + 2);
      background.setAttribute('fill', 'rgba(255, 255, 255, 0.9)');
      background.setAttribute('stroke', cableColor);
      background.setAttribute('stroke-width', '0.5');
      background.setAttribute('rx', '2');
      background.setAttribute('pointer-events', 'none');
      
      svg.appendChild(background);
      svg.appendChild(text);
      
      // Se h√° muitas conex√µes entre os mesmos equipamentos e modo agrupado, adicionar indicador visual
      if (totalConnections >= 3 && connectionIndex === 0 && !gridData.distributedConnections) {
        // Criar um indicador de m√∫ltiplas conex√µes
        const summaryText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        const summaryX = (points.x1 + points.x2) / 2;
        const summaryY = (points.y1 + points.y2) / 2 + 25;
        
        summaryText.setAttribute('x', summaryX);
        summaryText.setAttribute('y', summaryY);
        summaryText.setAttribute('text-anchor', 'middle');
        summaryText.setAttribute('font-size', '9px');
        summaryText.setAttribute('font-family', 'Arial, sans-serif');
        summaryText.setAttribute('fill', '#666');
        summaryText.setAttribute('pointer-events', 'none');
        summaryText.setAttribute('font-weight', 'bold');
        summaryText.textContent = `${totalConnections} conex√µes`;
        
        // Adicionar fundo ao texto de resumo
        const summaryBBox = summaryText.getBBox();
        const summaryBackground = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        summaryBackground.setAttribute('x', summaryBBox.x - 3);
        summaryBackground.setAttribute('y', summaryBBox.y - 1);
        summaryBackground.setAttribute('width', summaryBBox.width + 6);
        summaryBackground.setAttribute('height', summaryBBox.height + 2);
        summaryBackground.setAttribute('fill', 'rgba(255, 255, 255, 0.8)');
        summaryBackground.setAttribute('stroke', '#666');
        summaryBackground.setAttribute('stroke-width', '0.5');
        summaryBackground.setAttribute('rx', '3');
        summaryBackground.setAttribute('pointer-events', 'none');
        
        svg.appendChild(summaryBackground);
        svg.appendChild(summaryText);
      }
      
      console.log(`‚úÖ Conex√£o desenhada com sucesso: ${connection.fromName} ‚Üí ${connection.toName}`);
      console.log(`  - Dire√ß√£o: (${points.x1},${points.y1}) ‚Üí (${points.x2},${points.y2})`);
      console.log(`  - Equipamentos: ${connection.fromName} ‚Üí ${connection.toName}`);
      console.log(`  - Path SVG criado: ${pathData}`);
      console.log(`  - Texto do cabo posicionado em: (${textX},${textY})`);
      console.log(`  - Cor do cabo: ${cableColor}`);
    }

    // Manipular clique direito (remover equipamento)
    function handleCellRightClick(cell, row, col) {
      if (cell.classList.contains('occupied')) {
        const name = cell.querySelector('.name').textContent;
        if (confirm(`Remover ${name} desta posi√ß√£o?`)) {
          cell.innerHTML = '';
          cell.classList.remove('occupied', 'keystone');
          delete cell.dataset.keystone;
          updateStatus(`${name} removido da posi√ß√£o (${row}, ${col})`);
        }
      }
    }

    // Atualizar status com debounce
    let statusTimeout = null;
    function updateStatus(message) {
      if (statusTimeout) {
        clearTimeout(statusTimeout);
      }
      statusTimeout = setTimeout(() => {
        statusBar.textContent = message;
        if (statusInfo) {
          statusInfo.textContent = message;
        }
      }, 10);
    }

    // Salvar layout
    async function saveLayout() {
      if (!gridData.currentSalaId) {
        alert('Nenhuma sala selecionada! Selecione uma sala primeiro.');
        return;
      }
      
      try {
        updateStatus('Salvando layout...');
        
        const layout = {
          grid: {
            rows: gridData.rows,
            cols: gridData.cols
          },
          equipment: [],
          connections: gridData.connections
        };
        
        // Coleta equipamentos posicionados
        document.querySelectorAll('.grid-cell.occupied, .grid-cell.text-occupied').forEach(cell => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          const img = cell.querySelector('img');
          const name = cell.querySelector('.name');
          const textElement = cell.querySelector('.text-element');
          
          // Verificar se √© um keystone
          const isKeystone = cell.classList.contains('keystone');
          const isText = cell.classList.contains('text-occupied');
          
          if (isText) {
            // √â um elemento de texto
            layout.equipment.push({
              row: row,
              col: col,
              type: 'text',
              content: textElement ? textElement.textContent.trim() : '',
              isText: true
            });
          } else {
            // √â um equipamento
            layout.equipment.push({
              row: row,
              col: col,
              src: img ? img.src : null,
              name: name ? name.textContent : '',
              isKeystone: isKeystone,
              keystone: isKeystone ? cell.dataset.keystone : null,
              type: 'equipment'
            });
          }
        });
        
        console.log('Layout a ser salvo:', layout);
        
        const response = await fetch(`/api/salas/${gridData.currentSalaId}/layout`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(layout)
        });
        
        if (response.ok) {
          updateStatus('‚úÖ Layout salvo com sucesso!');
          alert('Layout salvo com sucesso!');
        } else {
          const errorText = await response.text();
          console.error('Erro ao salvar layout:', errorText);
          updateStatus('‚ùå Erro ao salvar layout');
          alert(`Erro ao salvar layout: ${errorText}`);
        }
      } catch (error) {
        console.error('Erro ao salvar:', error);
        updateStatus('‚ùå Erro ao salvar layout');
        alert(`Erro ao salvar layout: ${error.message}`);
      }
    }

    // Carregar layout
    async function loadLayout(salaId) {
      try {
        updateStatus('Carregando layout...');
        
        // Buscar informa√ß√µes da sala
        let salaName = `Sala ${salaId}`;
        try {
          const salaResponse = await fetch(`/api/salas/${salaId}`);
          if (salaResponse.ok) {
            const salaData = await salaResponse.json();
            console.log('Dados da sala recebidos:', salaData); // Debug
            salaName = salaData.nome || salaName;
            console.log('Nome da sala definido como:', salaName); // Debug
          }
        } catch (error) {
          console.warn('N√£o foi poss√≠vel buscar informa√ß√µes da sala:', error);
        }
        
        // Atualizar display da sala atual
        updateCurrentSalaDisplay(salaName);
        
        const response = await fetch(`/api/salas/${salaId}/layout`);
        if (!response.ok) {
          updateStatus('Nenhum layout encontrado para esta sala');
          return;
        }
        
        const layout = await response.json();
        console.log('Layout carregado:', layout);
        
        // Verificar se a grade existe antes de limpar
        const cells = document.querySelectorAll('.grid-cell');
        if (cells.length > 0) {
          // Limpa grade atual
          cells.forEach(cell => {
            cell.innerHTML = '';
            cell.classList.remove('occupied', 'keystone');
          });
        }
        
        // Posiciona equipamentos
        if (layout.equipment) {
          layout.equipment.forEach(item => {
            const cell = document.querySelector(`[data-row="${item.row}"][data-col="${item.col}"]`);
            if (cell) {
              if (item.isText) {
                // √â um elemento de texto
                cell.innerHTML = `
                  <div class="text-element">
                    ${item.content || ''}
                  </div>
                `;
                cell.classList.add('text-occupied');
                
                // Torna o texto arrast√°vel
                const textElement = cell.querySelector('.text-element');
                if (textElement) {
                  makeTextDraggable(textElement);
                }
              } else if (item.isKeystone) {
                // √â um keystone
                cell.innerHTML = `
                  <div class="equipment-slot keystone-slot">
                    <div class="keystone-icon">üîå</div>
                    <div class="name">${item.name}</div>
                  </div>
                `;
                cell.classList.add('occupied', 'keystone');
                cell.dataset.keystone = item.keystone;
              } else {
                // √â um equipamento normal
                const sizeClass = getEquipmentSizeClass(item.name);
                cell.innerHTML = `
                  <div class="equipment-slot ${sizeClass}">
                    <img src="${cacheBust(item.src ? (item.src.startsWith('/') ? item.src : '/' + item.src.replace(/^\/+/, '')) : '')}" alt="${item.name}">
                    <div class="name">${item.name}</div>
                  </div>
                `;
                cell.classList.add('occupied');
              }
              
              // Torna o equipamento arrast√°vel (se n√£o for texto)
              if (!item.isText) {
                const equipmentSlot = cell.querySelector('.equipment-slot');
                if (equipmentSlot) {
                  makeEquipmentDraggable(equipmentSlot);
                }
              }
            }
          });
          
          console.log(`${layout.equipment.length} elementos posicionados`);
        }
        
        // Carrega conex√µes
        const rawConnections = layout.connections || [];
        console.log('Conex√µes carregadas do layout:', rawConnections);
        
        // Para o modo distribu√≠do, manter todas as conex√µes (incluindo m√∫ltiplas entre os mesmos equipamentos)
        gridData.connections = rawConnections;
        console.log('Conex√µes carregadas no gridData:', gridData.connections);
        
        // Garantir que o modo distribu√≠do est√° ativo
        gridData.distributedConnections = true;
        console.log('‚úÖ Modo distribu√≠do ativado ao carregar layout');
        
        if (rawConnections.length > 0) {
          console.log(`‚úÖ ${rawConnections.length} conex√µes carregadas do layout`);
        }
        
        // Sempre redesenhar conex√µes ap√≥s carregar layout
        setTimeout(() => {
          console.log('=== REDESENHANDO CONEX√ïES AP√ìS CARREGAR LAYOUT ===');
          redrawAllConnections();
        }, 100);
        
        // Verifica√ß√£o adicional ap√≥s um delay maior
        setTimeout(() => {
          if (gridData.connections.length > 0) {
            const svg = document.getElementById('svg-connections');
            const paths = svg ? svg.querySelectorAll('path') : [];
            if (paths.length === 0) {
              console.log('Conex√µes n√£o foram desenhadas, tentando novamente...');
              redrawAllConnections();
            }
          }
        }, 500);
        
        updateStatus(`‚úÖ Layout carregado da sala ${salaId}`);
        
      } catch (error) {
        console.error('Erro ao carregar layout:', error);
        updateStatus('‚ùå Erro ao carregar layout');
        alert(`Erro ao carregar layout: ${error.message}`);
      }
    }

    // Mostrar modal de sele√ß√£o de sala
    async function showSalaModal(action) {
      salaModal.style.display = 'flex';
      
      try {
        const response = await fetch('/api/salas');
        const salas = await response.json();
        
        salaSelect.innerHTML = '<option value="">Carregando salas...</option>';
        salas.forEach(sala => {
          const option = document.createElement('option');
          option.value = sala.id;
          option.textContent = sala.nome || `Sala ${sala.id}`;
          salaSelect.appendChild(option);
        });
        
        // Configura a√ß√£o do bot√£o confirmar
        btnConfirmSala.onclick = () => {
          const salaId = salaSelect.value;
          if (!salaId) {
            alert('Selecione uma sala!');
            return;
          }
          
          gridData.currentSalaId = salaId;
          salaModal.style.display = 'none';
          
          if (action === 'save') {
            saveLayout();
          } else if (action === 'load') {
            loadLayout(salaId);
          }
        };
        
      } catch (error) {
        console.error('Erro ao carregar salas:', error);
        salaSelect.innerHTML = '<option value="">Erro ao carregar salas</option>';
      }
    }

    // Limpar tudo
    function clearAll() {
      if (confirm('Tem certeza que deseja limpar todo o layout?')) {
        clearAllWithoutConfirmation();
      }
    }

    // Limpar tudo sem confirma√ß√£o
    function clearAllWithoutConfirmation() {
      const cells = document.querySelectorAll('.grid-cell');
      if (cells.length > 0) {
        cells.forEach(cell => {
          cell.innerHTML = '';
          cell.classList.remove('occupied', 'selected', 'connectable', 'removable', 'keystone', 'text-occupied');
          delete cell.dataset.keystone;
        });
      }
      
      gridData.connections = [];
      gridData.connectionStart = null;
      gridData.selectedConnection = null;
      
      // Limpar sele√ß√£o de equipamento
      equipmentSelect.value = '';
      equipmentPreview.classList.add('hidden');
      gridData.selectedEquipment = null;
      
      // S√≥ redesenha se o SVG existir
      const svg = document.getElementById('svg-connections');
      if (svg) {
        redrawAllConnections();
      }
      
      updateStatus('Layout limpo');
      
      // Limpar display da sala atual
      updateCurrentSalaDisplay(null);
    }

    // Fun√ß√£o para atualizar o display da sala atual
    function updateCurrentSalaDisplay(salaName) {
      console.log('updateCurrentSalaDisplay chamada com:', salaName); // Debug
      const displayElement = document.getElementById('currentSalaNameDisplay');
      console.log('Elemento encontrado:', displayElement); // Debug
      if (displayElement) {
        if (salaName) {
          displayElement.textContent = salaName;
          console.log('Nome da sala definido no elemento:', displayElement.textContent); // Debug
        } else {
          displayElement.textContent = 'Nenhuma sala selecionada';
        }
      } else {
        console.error('Elemento currentSalaNameDisplay n√£o encontrado!'); // Debug
      }
    }

    // Fun√ß√£o para mostrar modal inicial
    function showInitialModal() {
      initialModal.style.display = 'flex';
      modalState.currentStep = 1;
      modalState.action = null;
      modalState.selectedSala = null;
      modalState.layoutExists = false;
      
      // Mostra passo 1
      step1.classList.add('active');
      step2.classList.remove('active');
      
      // Carregar salas automaticamente
      loadSalas();
    }

    // Fun√ß√£o para carregar salas
    async function loadSalas() {
      try {
        const response = await fetch('/api/salas');
        const salas = await response.json();
        
        salaSelectInitial.innerHTML = '<option value="">Selecione uma sala...</option>';
        salas.forEach(sala => {
          const option = document.createElement('option');
          option.value = sala.id;
          option.textContent = sala.nome || `Sala ${sala.id}`;
          option.dataset.sala = JSON.stringify(sala);
          salaSelectInitial.appendChild(option);
        });
      } catch (error) {
        console.error('Erro ao carregar salas:', error);
        salaSelectInitial.innerHTML = '<option value="">Erro ao carregar salas</option>';
      }
    }

    // Fun√ß√£o para verificar se layout existe
    async function checkLayoutExists(salaId) {
      try {
        const response = await fetch(`/api/salas/${salaId}/layout`);
        return response.ok;
      } catch (error) {
        return false;
      }
    }

    // Fun√ß√£o para mostrar informa√ß√µes da sala
    function showSalaInfo(sala) {
      salaDetails.innerHTML = `
        <p><strong>Nome:</strong> ${sala.nome || 'N√£o informado'}</p>
        <p><strong>ID:</strong> ${sala.id}</p>
      `;
      salaInfo.style.display = 'block';
    }

    // Fun√ß√£o para atualizar status do layout
    async function updateLayoutStatus(salaId) {
      const exists = await checkLayoutExists(salaId);
      modalState.layoutExists = exists;
      
      if (exists) {
        layoutStatus.innerHTML = '<span class="layout-status exists">‚úÖ Layout existente</span>';
      } else {
        layoutStatus.innerHTML = '<span class="layout-status new">üÜï Sem layout</span>';
      }
    }

    // Fun√ß√£o para ir para pr√≥ximo passo
    function nextStep() {
      const currentStepElement = document.querySelector(`#step${modalState.currentStep}`);
      currentStepElement.classList.remove('active');
      
      modalState.currentStep++;
      const nextStepElement = document.querySelector(`#step${modalState.currentStep}`);
      nextStepElement.classList.add('active');
    }

    // Fun√ß√£o para voltar passo
    function prevStep() {
      const currentStepElement = document.querySelector(`#step${modalState.currentStep}`);
      currentStepElement.classList.remove('active');
      
      modalState.currentStep--;
      const nextStepElement = document.querySelector(`#step${modalState.currentStep}`);
      nextStepElement.classList.add('active');
    }

    // Fun√ß√£o para confirmar a√ß√£o
    function confirmAction() {
      // Se existe layout, carrega. Se n√£o existe, cria novo
      if (modalState.layoutExists) {
        // Carregar layout existente
        gridData.currentSalaId = modalState.selectedSala.id;
        loadLayout(modalState.selectedSala.id);
        updateStatus(`Layout carregado para ${modalState.selectedSala.nome || `Sala ${modalState.selectedSala.id}`}`);
      } else {
        // Criar novo layout
        gridData.currentSalaId = modalState.selectedSala.id;
        clearAll();
        updateStatus(`Novo layout iniciado para ${modalState.selectedSala.nome || `Sala ${modalState.selectedSala.id}`}`);
      }
      
      // Atualizar display da sala atual
      updateCurrentSalaDisplay(modalState.selectedSala.nome || `Sala ${modalState.selectedSala.id}`);
      
      initialModal.style.display = 'none';
    }

    // Fun√ß√£o para atualizar conex√µes ap√≥s mover equipamento - otimizada
    function updateConnectionsAfterMove(fromRow, fromCol, toRow, toCol, equipmentName) {
      // Atualiza posi√ß√µes das conex√µes
      const connections = gridData.connections;
      for (let i = 0; i < connections.length; i++) {
        const connection = connections[i];
        if (connection.from.row === fromRow && connection.from.col === fromCol) {
          connection.from.row = toRow;
          connection.from.col = toCol;
        }
        if (connection.to.row === fromRow && connection.to.col === fromCol) {
          connection.to.row = toRow;
          connection.to.col = toCol;
        }
      }
      
      // Redesenha todas as conex√µes
      redrawAllConnections();
    }

    // Fun√ß√£o para mover equipamento - otimizada
    function moveEquipment(fromRow, fromCol, toRow, toCol) {
      const fromCell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
      const toCell = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
      
      if (!fromCell || !toCell) return;
      
      // Pega o conte√∫do do equipamento
      const equipmentSlot = fromCell.querySelector('.equipment-slot');
      const textElement = fromCell.querySelector('.text-element');
      
      if (!equipmentSlot && !textElement) return;
      
      let elementName = '';
      let isKeystone = false;
      let isText = false;
      let keystoneData = null;
      
      if (equipmentSlot) {
        // √â um equipamento
        elementName = equipmentSlot.querySelector('.name').textContent;
        isKeystone = fromCell.classList.contains('keystone');
        keystoneData = isKeystone ? fromCell.dataset.keystone : null;
      } else if (textElement) {
        // √â um texto
        elementName = textElement.textContent.trim();
        isText = true;
      }
      
      // Remove da c√©lula original
      fromCell.innerHTML = '';
      fromCell.classList.remove('occupied', 'keystone', 'text-occupied');
      delete fromCell.dataset.keystone;
      
      // Adiciona na nova c√©lula
      if (isText) {
        // √â um texto
        toCell.innerHTML = `
          <div class="text-element">
            ${elementName}
          </div>
        `;
        toCell.classList.add('text-occupied');
        
        // Torna o texto arrast√°vel
        const newTextElement = toCell.querySelector('.text-element');
        makeTextDraggable(newTextElement);
      } else if (isKeystone) {
        // √â um keystone - usar estrutura de keystone
        toCell.innerHTML = `
          <div class="equipment-slot keystone-slot">
            <div class="keystone-icon">üîå</div>
            <div class="name">${elementName}</div>
          </div>
        `;
        toCell.classList.add('occupied', 'keystone');
        if (keystoneData) {
          toCell.dataset.keystone = keystoneData;
        }
      } else {
        // √â um equipamento normal - usar estrutura com imagem
        const equipmentImg = equipmentSlot.querySelector('img');
        const rawSrc = equipmentImg ? equipmentImg.getAttribute('src') || equipmentImg.src : '';
        const normalized = normalizeImageSrc(rawSrc);
        toCell.innerHTML = `
          <div class="equipment-slot">
            <img src="${normalized}" alt="${elementName}">
            <div class="name">${elementName}</div>
          </div>
        `;
        toCell.classList.add('occupied');
      }
      
      // Torna o novo elemento arrast√°vel
      const newElement = toCell.querySelector('.equipment-slot, .text-element');
      if (newElement) {
        if (isText) {
          makeTextDraggable(newElement);
        } else {
          makeEquipmentDraggable(newElement);
        }
      }
      
      // Atualiza conex√µes (apenas para equipamentos)
      if (!isText) {
        updateConnectionsAfterMove(fromRow, fromCol, toRow, toCol, elementName);
      }
      
      updateStatus(`${isText ? 'Texto' : isKeystone ? 'Keystone' : 'Equipamento'} "${elementName}" movido`);
    }

    // Fun√ß√£o para lidar com drop - otimizada
    function handleDrop(e, cell, row, col) {
      if (gridData.connectionMode || gridData.removeMode) return;
      
      e.preventDefault();
      cell.classList.remove('drag-over');
      
      if (!gridData.dragState.isDragging || !gridData.dragState.draggedElement) return;
      
      const originalCell = gridData.dragState.originalCell;
      const originalRow = gridData.dragState.originalRow;
      const originalCol = gridData.dragState.originalCol;
      
      // Se a c√©lula de destino est√° ocupada, n√£o permite o drop
      if ((cell.classList.contains('occupied') || cell.classList.contains('text-occupied')) && cell !== originalCell) {
        return;
      }
      
      // Se √© a mesma c√©lula, n√£o faz nada
      if (cell === originalCell) {
        return;
      }
      
      // Move o equipamento ou texto
      moveEquipment(originalRow, originalCol, row, col);
    }

    // Fun√ß√£o para lidar com drag over - otimizada
    function handleDragOver(e, cell) {
      if (gridData.connectionMode || gridData.removeMode) return;
      
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }

    // Fun√ß√£o para lidar com drag enter - otimizada
    function handleDragEnter(e, cell) {
      if (gridData.connectionMode || gridData.removeMode) return;
      
      e.preventDefault();
      if (!cell.classList.contains('occupied') && !cell.classList.contains('text-occupied') || cell === gridData.dragState.originalCell) {
        cell.classList.add('drag-over');
      }
    }

    // Fun√ß√£o para lidar com drag leave - otimizada
    function handleDragLeave(e, cell) {
      if (gridData.connectionMode || gridData.removeMode) return;
      
      cell.classList.remove('drag-over');
    }

    // Fun√ß√£o para verificar se uma conex√£o j√° existe (evita duplica√ß√£o)
    function connectionExists(connection, existingConnections) {
      const connKey = `${connection.from.row}-${connection.from.col}-${connection.to.row}-${connection.to.col}`;
      const reverseKey = `${connection.to.row}-${connection.to.col}-${connection.from.row}-${connection.from.col}`;
      
      console.log(`üîç Verificando se conex√£o j√° existe:`);
      console.log(`  - Nova conex√£o: ${connection.fromName} (${connection.from.row},${connection.from.col}) ‚Üí ${connection.toName} (${connection.to.row},${connection.to.col})`);
      console.log(`  - Chave: ${connKey}`);
      console.log(`  - Chave reversa: ${reverseKey}`);
      console.log(`  - Total de conex√µes existentes: ${existingConnections.length}`);
      
      const exists = existingConnections.some(existing => {
        const existingKey = `${existing.from.row}-${existing.from.col}-${existing.to.row}-${existing.to.col}`;
        const existingReverseKey = `${existing.to.row}-${existing.to.col}-${existing.from.row}-${existing.from.col}`;
        
        const matches = existingKey === connKey || existingKey === reverseKey || 
                       existingReverseKey === connKey || existingReverseKey === reverseKey;
        
        if (matches) {
          console.log(`  - ‚ö†Ô∏è Conex√£o duplicada encontrada: ${existing.fromName} (${existing.from.row},${connection.from.col}) ‚Üí ${existing.toName} (${connection.to.row},${connection.to.col})`);
        }
        
        return matches;
      });
      
      console.log(`  - Resultado: ${exists ? 'EXISTE' : 'N√ÉO EXISTE'}`);
      return exists;
    }
    
    // Fun√ß√£o para calcular pontos de conex√£o distribu√≠dos
    function calculateDistributedConnectionPoints(from, to, connectionIndex, totalConnections) {
      // Calcula posi√ß√µes dos centros dos equipamentos
      const centerX1 = from.offsetLeft + from.offsetWidth/2;
      const centerY1 = from.offsetTop + from.offsetHeight/2;
      const centerX2 = to.offsetLeft + to.offsetWidth/2;
      const centerY2 = to.offsetTop + to.offsetHeight/2;
      
      // Se h√° apenas uma conex√£o, sempre usar pontos centrais
      if (totalConnections <= 1) {
        return {
          x1: centerX1,
          y1: centerY1,
          x2: centerX2,
          y2: centerY2
        };
      }
      
      // Calcular offset baseado no n√∫mero de conex√µes
      const maxOffset = Math.min(from.offsetWidth, from.offsetHeight) * 0.3; // 30% do tamanho do equipamento
      const offset = (maxOffset * (connectionIndex - (totalConnections - 1) / 2)) / totalConnections;
      
      // Calcular dire√ß√£o da conex√£o
      const dx = centerX2 - centerX1;
      const dy = centerY2 - centerY1;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance === 0) {
        return {
          x1: centerX1,
          y1: centerY1,
          x2: centerX2,
          y2: centerY2
        };
      }
      
      // Calcular vetor perpendicular para distribuir as conex√µes
      const perpX = -dy / distance;
      const perpY = dx / distance;
      
      // Aplicar offset perpendicular
      const x1 = centerX1 + perpX * offset;
      const y1 = centerY1 + perpY * offset;
      const x2 = centerX2 + perpX * offset;
      const y2 = centerY2 + perpY * offset;
      
      return { x1, y1, x2, y2 };
    }

    // Fun√ß√£o para carregar dados reais da sala
    async function loadRealData() {
      if (!gridData.currentSalaId) {
        alert('Nenhuma sala selecionada! Selecione uma sala primeiro.');
        return;
      }

      try {
        updateStatus('Carregando dados reais da sala...');
        
        console.log('=== INICIANDO CARREGAMENTO DE DADOS REAIS ===');
        console.log('Sala ID:', gridData.currentSalaId);
        
        // Buscar equipamentos da sala
        console.log('Fazendo fetch para equipamentos da sala...');
        const equipResponse = await fetch(`/equipamentos?sala_id=${gridData.currentSalaId}`);
        console.log('Resposta da API de equipamentos da sala:', equipResponse.status, equipResponse.ok);
        
        let equipamentos = [];
        
        // Processar equipamentos da sala
        if (equipResponse.ok) {
          const equipamentosText = await equipResponse.text();
          try {
            equipamentos = JSON.parse(equipamentosText);
            console.log('Equipamentos da sala (JSON v√°lido):', equipamentos);
          } catch (error) {
            console.warn('API retornou p√°gina de login em vez de JSON para equipamentos da sala.');
            equipamentos = [];
          }
        }
        
        // Buscar equipamentos em estoque que t√™m conex√µes com a sala
        console.log('Fazendo fetch para equipamentos em estoque...');
        const estoqueResponse = await fetch('/equipamentos?sala_id=null');
        console.log('Resposta da API de equipamentos em estoque:', estoqueResponse.status, estoqueResponse.ok);
        
        let equipamentosEstoque = [];
        
        // Processar equipamentos em estoque
        if (estoqueResponse.ok) {
          const estoqueText = await estoqueResponse.text();
          try {
            equipamentosEstoque = JSON.parse(estoqueText);
            console.log('Equipamentos em estoque (JSON v√°lido):', equipamentosEstoque);
          } catch (error) {
            console.warn('API retornou p√°gina de login em vez de JSON para equipamentos em estoque.');
            equipamentosEstoque = [];
          }
        }
        
        // Combinar equipamentos da sala e em estoque
        const todosEquipamentos = [...equipamentos, ...equipamentosEstoque];
        console.log('Todos os equipamentos (sala + estoque):', todosEquipamentos);
        
        console.log('Todos os equipamentos (sala + estoque):', todosEquipamentos);
        console.log('Detalhes dos equipamentos:');
        todosEquipamentos.forEach((equip, index) => {
          console.log(`  ${index + 1}. ${equip.nome}: id=${equip.id}, sala_id=${equip.sala_id}, tipo=${equip.tipo}`);
        });
        
        // Buscar keystones dos equipamentos da sala
        const keystonesEquipamentos = await loadKeystonesFromEquipamentos(todosEquipamentos);
        
        console.log('Keystones encontrados:', keystonesEquipamentos);
        console.log('Tipo de keystones:', typeof keystonesEquipamentos);
        console.log('√â array?', Array.isArray(keystonesEquipamentos));
        console.log('Comprimento:', keystonesEquipamentos ? keystonesEquipamentos.length : 'null/undefined');
        
        // Buscar conex√µes reais da sala - API correta
        console.log('Fazendo fetch para conex√µes...');
        const connResponse = await fetch(`/conexoes-cabos/sala/${gridData.currentSalaId}`);
        console.log('Resposta da API de conex√µes:', connResponse.status, connResponse.ok);
        
        if (!connResponse.ok) {
          throw new Error('Erro ao carregar conex√µes da sala');
        }
        
        const conexoesText = await connResponse.text();
        console.log('Texto da resposta da API de conex√µes (primeiros 200 chars):', conexoesText.substring(0, 200));
        let conexoes = [];
        
        // Verificar se a resposta √© JSON v√°lido ou se √© a p√°gina de login
        try {
          conexoes = JSON.parse(conexoesText);
          console.log('‚úÖ Conex√µes reais da sala (JSON v√°lido):', conexoes);
          // Garantir que todos os equipamentos referenciados nas conex√µes existam em todosEquipamentos,
          // mesmo que estejam ocultos em outras listagens (ex.: Ponto Usu√°rio HDMI/USB)
          try {
            const idsReferenciados = new Set();
            conexoes.forEach(c => {
              if (c.equipamento_origem_id) idsReferenciados.add(c.equipamento_origem_id);
              if (c.equipamento_destino_id) idsReferenciados.add(c.equipamento_destino_id);
            });

            const idsJaCarregados = new Set(todosEquipamentos.map(e => e.id));
            const idsFaltantes = Array.from(idsReferenciados).filter(id => !idsJaCarregados.has(id));

            if (idsFaltantes.length > 0) {
              console.log('üîÅ Buscando equipamentos faltantes referenciados nas conex√µes:', idsFaltantes);
              const fetched = await Promise.all(idsFaltantes.map(id => fetch(`/equipamentos/${id}`).then(r => r.ok ? r.json() : null).catch(() => null)));
              fetched.filter(Boolean).forEach(eq => {
                // Inserir no array base para que seja posicionado/renderizado e usado nas buscas
                todosEquipamentos.push(eq);
              });
              console.log('‚úÖ Equipamentos faltantes adicionados ao contexto:', fetched.filter(Boolean));
            }
          } catch (e) {
            console.warn('N√£o foi poss√≠vel garantir todos os equipamentos referenciados:', e);
          }
          
          // Filtrar conex√µes que envolvem equipamentos em estoque
          const conexoesComEstoque = conexoes.filter(conexao => {
            const equipOrigem = todosEquipamentos.find(e => e.id === conexao.equipamento_origem_id);
            const equipDestino = todosEquipamentos.find(e => e.id === conexao.equipamento_destino_id);
            
            // Incluir se pelo menos um dos equipamentos est√° em estoque (sala_id = null)
            return (equipOrigem && equipOrigem.sala_id === null) || 
                   (equipDestino && equipDestino.sala_id === null);
          });
          
          if (conexoesComEstoque.length > 0) {
            console.log('‚úÖ Conex√µes com equipamentos em estoque encontradas:', conexoesComEstoque);
            // NOTA: N√£o adicionar novamente ao array para evitar duplica√ß√£o
            // As conex√µes com estoque j√° est√£o inclu√≠das no array original
          }
          
        } catch (error) {
          console.warn('‚ùå API retornou p√°gina de login em vez de JSON. Usando dados simulados.');
          console.log('Erro de parse:', error.message);
          console.log('Resposta da API:', conexoesText.substring(0, 200) + '...');
          
          // Criar dados simulados baseados nos keystones encontrados
          console.log('Criando dados simulados...');
          conexoes = keystonesEquipamentos.map((keystone, index) => ({
            id: index + 1,
            equipamento_origem_id: keystone.equipamento_sala_id,
            equipamento_destino_id: null,
            porta_destino: keystone.porta_original.numero_porta,
            keystone_destino: keystone.keystone,
            codigo_cabo: `ETH-${(index + 1).toString().padStart(3, '0')}`,
            nome_cabo: `Ethernet-${(index + 1).toString().padStart(3, '0')}`,
            tipo_cabo: 'Ethernet'
          }));
          
          console.log('‚úÖ Dados simulados criados:', conexoes);
        }
        
        console.log('Conex√µes reais da sala:', conexoes);
        console.log('=== DETALHES DAS CONEX√ïES REAIS ===');
        conexoes.forEach((conexao, index) => {
          console.log(`Conex√£o ${index + 1}:`, conexao);
          console.log(`  - equipamento_origem_id: ${conexao.equipamento_origem_id}`);
          console.log(`  - equipamento_destino_id: ${conexao.equipamento_destino_id}`);
          console.log(`  - porta_destino: ${conexao.porta_destino}`);
          console.log(`  - keystone_destino: ${conexao.keystone_destino}`);
          console.log(`  - codigo_cabo: ${conexao.codigo_cabo}`);
          console.log(`  - nome_cabo: ${conexao.nome_cabo}`);
          console.log(`  - tipo_cabo: ${conexao.tipo_cabo}`);
          console.log(`  - id: ${conexao.id}`);
        });
        console.log('=== FIM DOS DETALHES ===');
        
        // Mapear keystones com as conex√µes reais para obter os nomes corretos dos cabos
        console.log('=== INICIANDO MAPEAMENTO DE KEYSTONES ===');
        console.log('Total de keystones para mapear:', keystonesEquipamentos.length);
        console.log('Total de conex√µes dispon√≠veis:', conexoes.length);
        
        const keystonesComConexoes = keystonesEquipamentos.map(keystone => {
          console.log(`\n--- Mapeando keystone: ${keystone.keystone} ---`);
          console.log(`Dados do keystone:`, keystone);
          console.log(`  - equipamento_sala_id: ${keystone.equipamento_sala_id}`);
          console.log(`  - porta_original.numero_porta: ${keystone.porta_original.numero_porta}`);
          console.log(`  - codigo_cabo original: ${keystone.codigo_cabo}`);
          
          // Buscar conex√£o que conecta a este keystone
          const conexao = conexoes.find(conn => {
            console.log(`\n  Verificando conex√£o:`, conn);
            console.log(`    - equipamento_origem_id: ${conn.equipamento_origem_id}`);
            console.log(`    - equipamento_destino_id: ${conn.equipamento_destino_id}`);
            console.log(`    - porta_destino: ${conn.porta_destino}`);
            console.log(`    - keystone_destino: ${conn.keystone_destino}`);
            
            // Verificar se a conex√£o √© para um keystone (porta do patch panel)
            const isKeystoneConnection = conn.equipamento_destino_id === 10 || // Patch panel ID
                                       conn.porta_destino === keystone.porta_original.numero_porta ||
                                       conn.keystone_destino === keystone.keystone;
            
            console.log(`    - isKeystoneConnection: ${isKeystoneConnection}`);
            
            // Verificar se o equipamento de origem corresponde
            const equipOrigem = equipamentos.find(e => e.id === conn.equipamento_origem_id);
            console.log(`    - equipOrigem encontrado:`, equipOrigem);
            
            // Buscar o equipamento correto baseado no nome do equipamento da porta
            const equipamentoCorreto = equipamentos.find(e => 
              e.nome.toLowerCase().includes(keystone.equipamento_nome?.toLowerCase() || '') ||
              keystone.equipamento_nome?.toLowerCase().includes(e.nome.toLowerCase())
            );
            
            const isEquipamentoCorreto = equipOrigem && equipamentoCorreto && 
                                        equipOrigem.id === equipamentoCorreto.id;
            
            console.log(`    - equipamentoCorreto:`, equipamentoCorreto);
            console.log(`    - isEquipamentoCorreto: ${isEquipamentoCorreto}`);
            console.log(`    - Resultado final: ${isKeystoneConnection && isEquipamentoCorreto}`);
            
            return isKeystoneConnection && isEquipamentoCorreto;
          });
          
          if (conexao) {
            console.log(`‚úÖ Conex√£o encontrada para keystone ${keystone.keystone}:`, conexao);
            console.log(`  - C√≥digo do cabo na conex√£o: ${conexao.codigo_cabo}`);
            console.log(`  - Nome do cabo na conex√£o: ${conexao.nome_cabo}`);
            
            const resultado = {
              ...keystone,
              codigo_cabo: conexao.codigo_cabo || conexao.nome_cabo || keystone.codigo_cabo
            };
            
            console.log(`  - C√≥digo do cabo final: ${resultado.codigo_cabo}`);
            return resultado;
          } else {
            console.log(`‚ùå Nenhuma conex√£o encontrada para keystone ${keystone.keystone}`);
            console.log(`  - Usando c√≥digo do cabo original: ${keystone.codigo_cabo}`);
            return keystone;
          }
        });
        
        console.log('Keystones com conex√µes mapeadas:', keystonesComConexoes);
        
        // Verificar se o mapeamento funcionou
        console.log('=== VERIFICA√á√ÉO DO MAPEAMENTO ===');
        keystonesComConexoes.forEach((keystone, index) => {
          console.log(`Keystone ${index + 1}: ${keystone.keystone}`);
          console.log(`  - C√≥digo do cabo original: ${keystone.codigo_cabo}`);
          console.log(`  - Equipamento sala ID: ${keystone.equipamento_sala_id}`);
          console.log(`  - N√∫mero da porta: ${keystone.porta_original.numero_porta}`);
          
          // Verificar se foi mapeado com uma conex√£o real
          const conexaoEncontrada = conexoes.find(conn => {
            return (conn.equipamento_destino_id === null || 
                   conn.porta_destino === keystone.porta_original.numero_porta ||
                   conn.keystone_destino === keystone.keystone) &&
                   equipamentos.find(e => e.id === conn.equipamento_origem_id);
          });
          
          if (conexaoEncontrada) {
            console.log(`  - ‚úÖ Mapeado com conex√£o real: ${conexaoEncontrada.codigo_cabo || conexaoEncontrada.nome_cabo}`);
          } else {
            console.log(`  - ‚ùå N√ÉO mapeado com conex√£o real`);
          }
        });
        console.log('=== FIM DA VERIFICA√á√ÉO ===');
        
        // Limpar grade atual e conex√µes existentes
        clearAll();
        
        // Limpar array de conex√µes para evitar duplica√ß√µes
        gridData.connections = [];
        console.log('‚úÖ Array de conex√µes limpo para evitar duplica√ß√µes');
        
        // For√ßar modo distribu√≠do
        gridData.distributedConnections = true;
        console.log('‚úÖ Modo distribu√≠do for√ßado como true');
        
        // Fun√ß√£o para verificar se uma conex√£o j√° existe (evita duplica√ß√£o)
        function connectionExists(connection, existingConnections) {
          const connKey = `${connection.from.row}-${connection.from.col}-${connection.to.row}-${connection.to.col}`;
          const reverseKey = `${connection.to.row}-${connection.to.col}-${connection.from.row}-${connection.from.col}`;
          
          console.log(`üîç Verificando se conex√£o j√° existe (loadRealData):`);
          console.log(`  - Nova conex√£o: ${connection.fromName} (${connection.from.row},${connection.from.col}) ‚Üí ${connection.toName} (${connection.to.row},${connection.to.col})`);
          console.log(`  - CableInfo: ${connection.cableInfo}`);
          console.log(`  - Chave: ${connKey}`);
          console.log(`  - Chave reversa: ${reverseKey}`);
          console.log(`  - Total de conex√µes existentes: ${existingConnections.length}`);
          
          // Verificar se √© uma conex√£o EXATAMENTE igual (mesma posi√ß√£o E mesmo cableInfo)
          const exists = existingConnections.some(existing => {
            const existingKey = `${existing.from.row}-${existing.from.col}-${existing.to.row}-${existing.to.col}`;
            const existingReverseKey = `${existing.to.row}-${existing.to.col}-${existing.from.row}-${existing.from.col}`;
            
            const samePosition = existingKey === connKey || existingKey === reverseKey || 
                               existingReverseKey === connKey || existingReverseKey === reverseKey;
            
            // Se a posi√ß√£o √© a mesma, verificar se o cableInfo tamb√©m √© o mesmo
            if (samePosition) {
              const sameCable = existing.cableInfo === connection.cableInfo;
              console.log(`  - ‚ö†Ô∏è Posi√ß√£o igual encontrada: ${existing.fromName} ‚Üí ${existing.toName}`);
              console.log(`  - CableInfo existente: ${existing.cableInfo}`);
              console.log(`  - CableInfo novo: ${connection.cableInfo}`);
              console.log(`  - Mesmo cabo: ${sameCable}`);
              
              // S√≥ considerar duplicada se for EXATAMENTE igual (mesma posi√ß√£o E mesmo cabo)
              return sameCable;
            }
            
            return false;
          });
          
          console.log(`  - Resultado: ${exists ? 'EXISTE (duplicada)' : 'N√ÉO EXISTE (nova)'}`);
          return exists;
        }
        
        // Verificar se a grade existe
        const cells = document.querySelectorAll('.grid-cell');
        if (cells.length === 0) {
          throw new Error('Grade n√£o encontrada. Atualize a grade primeiro.');
        }
        
        // Posicionar equipamentos automaticamente
        let equipCount = 0;
        let keystoneCount = 0;
        
        // Filtrar equipamentos que t√™m conex√µes com a sala (incluindo equipamentos em estoque)
        let equipamentosComConexoes = todosEquipamentos.filter(equip => {
          // Verificar se o equipamento tem conex√µes na sala
          const temConexao = conexoes.some(conexao => 
            conexao.equipamento_origem_id === equip.id || 
            conexao.equipamento_destino_id === equip.id
          );
          
          // Incluir se est√° na sala OU se est√° em estoque mas tem conex√£o com a sala
          return equip.sala_id == gridData.currentSalaId || 
                 (equip.sala_id === null && temConexao);
        });
        
        // Processar conex√µes via patch panel para criar keystones individuais
        const conexoesViaPatchPanel = conexoes.filter(conexao => conexao.tipo_destino === 'patch_panel');
        console.log('Conex√µes via patch panel encontradas:', conexoesViaPatchPanel);
        
        // Para cada conex√£o via patch panel, criar um keystone individual
        for (const conexao of conexoesViaPatchPanel) {
          const patchPanelId = conexao.equipamento_destino_id;
          const portaNumero = conexao.porta_destino;
          
          // Buscar informa√ß√µes do patch panel
          const patchPanelResponse = await fetch(`/patch-panels/${patchPanelId}`);
          if (patchPanelResponse.ok) {
            const patchPanel = await patchPanelResponse.json();
            
            // Criar nome do keystone baseado no patch panel e porta
            const prefixo = patchPanel.prefixo_keystone || 'kst'; // Usar prefixo do patch panel ou padr√£o
            const numeroPorta = portaNumero.toString().padStart(2, '0');
            const nomeKeystone = `${prefixo}--${numeroPorta}`;
            
            // Adicionar keystone √† lista
            keystonesEquipamentos.push({
              keystone: nomeKeystone,
              equipamento_sala_id: conexao.equipamento_origem_id,
              patch_panel_id: patchPanelId,
              patch_panel_nome: patchPanel.nome,
              porta_original: {
                numero_porta: portaNumero
              },
              codigo_cabo: conexao.codigo_cabo || `${prefixo}-${numeroPorta}`
            });
          }
        }
        
        console.log('Equipamentos com conex√µes na sala:', equipamentosComConexoes);
        
        // Primeiro posicionar equipamentos
        for (let row = 0; row < gridData.rows && equipCount < equipamentosComConexoes.length; row++) {
          for (let col = 0; col < gridData.cols && equipCount < equipamentosComConexoes.length; col++) {
            const equip = equipamentosComConexoes[equipCount];
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            if (cell && !cell.classList.contains('occupied')) {
              // Buscar imagem do equipamento
              console.log('=== DEBUG EQUIPAMENTO ===');
              console.log('Nome do equipamento:', equip.nome);
              console.log('Nome em lowercase:', equip.nome ? equip.nome.toLowerCase() : 'null');
              console.log('Tipo do equipamento:', equip.tipo);
              console.log('ID do equipamento:', equip.id);
              console.log('Sala do equipamento:', equip.sala_id);
              console.log('Posi√ß√£o na grade:', `(${row},${col})`);
              console.log('========================');
              
              // Usar o sistema de mapeamento inteligente para encontrar a imagem
              let imgSrc = await findEquipmentImage(equip.tipo || equip.nome, equip.nome || '', equip.marca || '', equip.modelo || '');
              console.log('‚úÖ Imagem selecionada para', equip.nome, ':', imgSrc);
              
              // Normalizar o caminho da imagem
              let normalizedSrc = imgSrc;
              if (imgSrc && !imgSrc.startsWith('/')) {
                normalizedSrc = '/' + imgSrc.replace(/^\/+/, '');
              }
              const finalSrc = cacheBust(normalizedSrc);
              console.log('üîß Caminho final da imagem:', finalSrc);
              
              cell.innerHTML = `
                <div class="equipment-slot">
                  <img src="${finalSrc}" alt="${equip.nome}" onerror="console.error('Erro ao carregar imagem:', this.src); this.src='/static/img/equipamentos/pc-ctl.png';">
                  <div class="name">${equip.nome}</div>
                </div>
              `;
              
              cell.classList.add('occupied');
              
              // Torna o equipamento arrast√°vel
              const equipmentSlot = cell.querySelector('.equipment-slot');
              if (equipmentSlot) {
                makeEquipmentDraggable(equipmentSlot);
              }
              
              equipCount++;
            }
          }
        }
        
        // Depois posicionar keystones dos equipamentos
        console.log('Posicionando keystones:', keystonesEquipamentos);
        console.log('Equipamentos dispon√≠veis:', equipamentos);
        
        // Criar mapa de equipamentos para facilitar busca
        const equipMap = new Map();
        equipamentos.forEach((equip, index) => {
          equipMap.set(equip.id, { equip, index });
        });
        
        console.log('Mapa de equipamentos:', equipMap);
        
        // Posicionar keystones de forma simples - qualquer c√©lula vazia
        for (let i = 0; i < keystonesEquipamentos.length; i++) {
          const keystone = keystonesEquipamentos[i];
          console.log(`Processando keystone ${i + 1}:`, keystone);
          
          const equipInfo = equipMap.get(keystone.equipamento_sala_id);
          console.log(`Equipamento encontrado para keystone ${keystone.keystone}:`, equipInfo);
          
          // Tentar posicionar em qualquer c√©lula vazia
          let posicionado = false;
          
          // Buscar todas as c√©lulas vazias
          const cells = document.querySelectorAll('.grid-cell');
          console.log(`Total de c√©lulas na grade: ${cells.length}`);
          
          for (let j = 0; j < cells.length && !posicionado; j++) {
            const cell = cells[j];
            if (!cell.classList.contains('occupied')) {
              const row = parseInt(cell.dataset.row);
              const col = parseInt(cell.dataset.col);
              
              console.log(`Tentando posicionar keystone ${keystone.keystone} na c√©lula (${row}, ${col})`);
              
              try {
                createKeystoneVisual(keystone.keystone, row, col);
                keystoneCount++;
                posicionado = true;
                console.log(`‚úÖ Keystone ${keystone.keystone} posicionado com sucesso na posi√ß√£o (${row}, ${col})`);
              } catch (error) {
                console.error(`‚ùå Erro ao posicionar keystone ${keystone.keystone}:`, error);
              }
            }
          }
          
          if (!posicionado) {
            console.error(`‚ùå N√£o foi poss√≠vel posicionar keystone ${keystone.keystone} - nenhuma c√©lula vazia encontrada`);
          }
        }
        
        console.log(`Total de keystones posicionados: ${keystoneCount}`);
        
        // Criar conex√µes baseadas nos dados reais
        const connectionPromises = conexoes.map(async (conexao) => {
          // Encontrar equipamentos de origem e destino (incluindo equipamentos em estoque)
          const fromEquip = equipamentosComConexoes.find(e => e.id === conexao.equipamento_origem_id);
          
          // Para destino, verificar se √© patch panel (keystone) ou equipamento
          let toEquip = null;
          if (conexao.tipo_destino === 'patch_panel') {
            // Para patch panel, buscar o keystone correspondente
            const keystone = keystonesEquipamentos.find(k => 
              k.patch_panel_id === conexao.equipamento_destino_id && 
              k.porta_original.numero_porta === conexao.porta_destino
            );
            
            if (keystone) {
              toEquip = {
                id: keystone.keystone,
                nome: keystone.keystone,
                tipo: 'Keystone',
                sala_id: gridData.currentSalaId
              };
            }
          } else {
            // Para equipamento normal
            toEquip = equipamentosComConexoes.find(e => e.id === conexao.equipamento_destino_id);
          }
          
          if (fromEquip && toEquip) {
            // Encontrar c√©lulas onde est√£o os equipamentos
            const fromCell = findEquipmentCell(fromEquip.nome);
            const toCell = findEquipmentCell(toEquip.nome);
            
            if (fromCell && toCell) {
              const fromRow = parseInt(fromCell.dataset.row);
              const fromCol = parseInt(fromCell.dataset.col);
              const toRow = parseInt(toCell.dataset.row);
              const toCol = parseInt(toCell.dataset.col);
              
              const connection = {
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                fromName: fromEquip.nome,
                toName: toEquip.nome,
                cableInfo: conexao.codigo_cabo || `${conexao.tipo_cabo || 'Cabo'}-${conexao.id}`,
                id: Date.now() + Math.random()
              };
              
              // Verificar se a conex√£o j√° existe antes de adicionar
              if (!connectionExists(connection, gridData.connections)) {
                gridData.connections.push(connection);
                drawConnection(connection);
                console.log(`‚úÖ Conex√£o criada: ${fromEquip.nome} ‚Üí ${toEquip.nome} (${connection.cableInfo})`);
              } else {
                console.log(`‚ö†Ô∏è Conex√£o duplicada ignorada: ${fromEquip.nome} ‚Üí ${toEquip.nome} (${connection.cableInfo})`);
              }
            }
          }
        });
        
        // Criar conex√µes entre equipamentos e seus keystones
        console.log('=== CRIANDO CONEX√ïES ENTRE EQUIPAMENTOS E KEYSTONES ===');
        console.log('Keystones para conectar:', keystonesComConexoes);
        console.log('Equipamentos dispon√≠veis:', equipamentos);
        
        // Log detalhado dos IDs dos equipamentos
        console.log('IDs dos equipamentos:');
        equipamentos.forEach(equip => {
          console.log(`  - ${equip.nome}: id=${equip.id}, sala_id=${equip.sala_id}, tipo=${equip.tipo}`);
        });
        
        // Log das conex√µes reais para debug
        console.log('=== CONEX√ïES REAIS DISPON√çVEIS ===');
        conexoes.forEach((conexao, index) => {
          console.log(`Conex√£o ${index + 1}:`, conexao);
          console.log(`  - equipamento_origem_id: ${conexao.equipamento_origem_id}`);
          console.log(`  - equipamento_destino_id: ${conexao.equipamento_destino_id}`);
          console.log(`  - porta_destino: ${conexao.porta_destino}`);
          console.log(`  - keystone_destino: ${conexao.keystone_destino}`);
          console.log(`  - codigo_cabo: ${conexao.codigo_cabo}`);
          console.log(`  - nome_cabo: ${conexao.nome_cabo}`);
        });
        console.log('=== FIM DAS CONEX√ïES REAIS ===');
        
        // Criar conex√µes entre equipamentos e seus keystones
        console.log('=== CRIANDO CONEX√ïES ENTRE EQUIPAMENTOS E KEYSTONES ===');
        console.log('Keystones para conectar:', keystonesComConexoes);
        console.log('Equipamentos dispon√≠veis:', equipamentos);
        
        // Log detalhado dos IDs dos equipamentos
        console.log('IDs dos equipamentos:');
        equipamentos.forEach(equip => {
          console.log(`  - ${equip.nome}: id=${equip.id}, sala_id=${equip.sala_id}, tipo=${equip.tipo}`);
        });
        
        for (const keystone of keystonesComConexoes) {
          console.log(`\n--- Processando keystone: ${keystone.keystone} ---`);
          console.log(`Keystone equipamento_sala_id: ${keystone.equipamento_sala_id}`);
          console.log(`Dados completos do keystone:`, keystone);
          
          // Primeira tentativa: usar nome do equipamento da porta (se existir)
          let equipSelecionado = null;
          
          if (keystone.equipamento_nome) {
            console.log(`Tentando encontrar equipamento por nome da porta: "${keystone.equipamento_nome}"`);
            equipSelecionado = equipamentos.find(e => 
              e.nome.toLowerCase().includes(keystone.equipamento_nome.toLowerCase()) ||
              keystone.equipamento_nome.toLowerCase().includes(e.nome.toLowerCase())
            );
            
            if (equipSelecionado) {
              console.log(`‚úÖ Equipamento encontrado por nome da porta: ${equipSelecionado.nome}`);
            }
          }
          
          // Segunda tentativa: usar tipo do equipamento da porta (se existir)
          if (!equipSelecionado && keystone.equipamento_tipo) {
            console.log(`Tentando encontrar equipamento por tipo da porta: "${keystone.equipamento_tipo}"`);
            equipSelecionado = equipamentos.find(e => 
              e.tipo && e.tipo.toLowerCase().includes(keystone.equipamento_tipo.toLowerCase())
            );
            
            if (equipSelecionado) {
              console.log(`‚úÖ Equipamento encontrado por tipo da porta: ${equipSelecionado.nome}`);
            }
          }
          
          // Terceira tentativa: usar equipamento_sala_id
          if (!equipSelecionado) {
            console.log(`Tentando encontrar equipamento por ID: ${keystone.equipamento_sala_id}`);
            equipSelecionado = equipamentos.find(e => e.id == keystone.equipamento_sala_id);
            
            if (equipSelecionado) {
              console.log(`‚úÖ Equipamento encontrado por ID: ${equipSelecionado.nome}`);
            }
          }
          
          // Quarta tentativa: distribui√ß√£o inteligente por proximidade
          if (!equipSelecionado) {
            console.log(`‚ùå Equipamento n√£o encontrado, usando distribui√ß√£o por proximidade`);
            
            const keystoneIndex = keystonesComConexoes.indexOf(keystone);
            const equipIndex = keystoneIndex % equipamentos.length;
            equipSelecionado = equipamentos[equipIndex];
            
            console.log(`‚úÖ Distribuindo keystone ${keystone.keystone} (√≠ndice ${keystoneIndex}) para equipamento ${equipSelecionado.nome} (√≠ndice ${equipIndex})`);
            
            // Tentar encontrar equipamento mais pr√≥ximo na grade
            const keystoneCellTemp = findEquipmentCell(keystone.keystone);
            if (keystoneCellTemp) {
              const keystoneRow = parseInt(keystoneCellTemp.dataset.row);
              const keystoneCol = parseInt(keystoneCellTemp.dataset.col);
              
              console.log(`Keystone ${keystone.keystone} est√° na posi√ß√£o (${keystoneRow}, ${keystoneCol})`);
              
              // Encontrar equipamento mais pr√≥ximo
              let equipMaisProximo = equipSelecionado;
              let menorDistancia = Infinity;
              
              for (const equip of equipamentos) {
                const equipCell = findEquipmentCell(equip.nome);
                if (equipCell) {
                  const equipRow = parseInt(equipCell.dataset.row);
                  const equipCol = parseInt(equipCell.dataset.col);
                  
                  const distancia = Math.sqrt(
                    Math.pow(equipRow - keystoneRow, 2) + 
                    Math.pow(equipCol - keystoneCol, 2)
                  );
                  
                  console.log(`  - ${equip.nome} na posi√ß√£o (${equipRow}, ${equipCol}): dist√¢ncia = ${distancia.toFixed(2)}`);
                  
                  if (distancia < menorDistancia) {
                    menorDistancia = distancia;
                    equipMaisProximo = equip;
                  }
                }
              }
              
              console.log(`‚úÖ Equipamento mais pr√≥ximo: ${equipMaisProximo.nome} (dist√¢ncia: ${menorDistancia.toFixed(2)})`);
              equipSelecionado = equipMaisProximo;
            }
          }
          
          if (equipSelecionado) {
            console.log(`Procurando c√©lula do equipamento: ${equipSelecionado.nome}`);
            const equipCell = findEquipmentCell(equipSelecionado.nome);
            console.log(`C√©lula do equipamento encontrada:`, equipCell);
            
            console.log(`Procurando c√©lula do keystone: ${keystone.keystone}`);
            const keystoneCell = findEquipmentCell(keystone.keystone);
            console.log(`C√©lula do keystone encontrada:`, keystoneCell);
            
            if (equipCell && keystoneCell) {
              const equipRow = parseInt(equipCell.dataset.row);
              const equipCol = parseInt(equipCell.dataset.col);
              const keystoneRow = parseInt(keystoneCell.dataset.row);
              const keystoneCol = parseInt(keystoneCell.dataset.col);
              
              console.log(`Criando conex√£o: ${equipSelecionado.nome}(${equipRow},${equipCol}) ‚Üí ${keystone.keystone}(${keystoneRow},${keystoneCol})`);
              
              // Usar c√≥digo do cabo da porta se existir, sen√£o criar um baseado no patch panel e porta
              let cableInfo = keystone.codigo_cabo;
              if (!cableInfo) {
                // Criar c√≥digo baseado no patch panel e n√∫mero da porta
                const patchPanelPrefix = keystone.patch_panel_nome ? keystone.patch_panel_nome.replace(/\s+/g, '').substring(0, 3) : 'PP';
                const portaNum = keystone.porta_original.numero_porta.toString().padStart(3, '0');
                cableInfo = `${patchPanelPrefix}-${portaNum}`;
              }
              
              console.log(`  - C√≥digo do cabo do keystone: ${keystone.codigo_cabo}`);
              console.log(`  - CableInfo final: ${cableInfo}`);
              
              const connection = {
                from: { row: equipRow, col: equipCol },
                to: { row: keystoneRow, col: keystoneCol },
                fromName: equipSelecionado.nome,
                toName: keystone.keystone,
                cableInfo: cableInfo,
                id: `keystone_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${keystone.porta_id || 'unknown'}`
              };
              
              console.log(`  - Connection object:`, connection);
              
              // Verificar se a conex√£o j√° existe antes de adicionar
              if (!connectionExists(connection, gridData.connections)) {
                gridData.connections.push(connection);
                drawConnection(connection);
                console.log(`‚úÖ Conex√£o criada com sucesso: ${equipSelecionado.nome} ‚Üí ${keystone.keystone} (${cableInfo})`);
              } else {
                console.log(`‚ö†Ô∏è Conex√£o duplicada ignorada: ${equipSelecionado.nome} ‚Üí ${keystone.keystone} (${cableInfo})`);
              }
            } else {
              console.warn(`‚ùå N√£o foi poss√≠vel criar conex√£o para keystone ${keystone.keystone}:`);
              if (!equipCell) console.warn(`  - C√©lula do equipamento ${equipSelecionado.nome} n√£o encontrada`);
              if (!keystoneCell) console.warn(`  - C√©lula do keystone ${keystone.keystone} n√£o encontrada`);
            }
          } else {
            console.warn(`‚ùå Nenhum equipamento encontrado para keystone ${keystone.keystone}`);
          }
        }
        
        console.log('=== FIM DAS CONEX√ïES ENTRE EQUIPAMENTOS E KEYSTONES ===');
        
        // Criar conex√µes entre equipamentos da sala (baseado nas conex√µes reais)
        console.log('=== CRIANDO CONEX√ïES ENTRE EQUIPAMENTOS DA SALA ===');
        console.log('Conex√µes reais dispon√≠veis:', conexoes);
        
        // Filtrar conex√µes que s√£o entre equipamentos da sala (n√£o keystones)
        const conexoesEntreEquipamentos = conexoes.filter(conexao => {
          // Usar todosEquipamentos (inclui itens ocultos em outras listagens, ex.: Ponto Usu√°rio)
          const equipOrigem = todosEquipamentos.find(e => e.id === conexao.equipamento_origem_id);
          
          // Para destino, verificar se √© patch panel ou equipamento
          let equipDestino = null;
          if (conexao.tipo_destino === 'patch_panel') {
            // Para patch panel, criar objeto simulado completo
            equipDestino = { 
              id: conexao.equipamento_destino_id,
              nome: conexao.equipamento_destino || 'Patch Panel',
              sala_id: gridData.currentSalaId 
            };
          } else {
            equipDestino = todosEquipamentos.find(e => e.id === conexao.equipamento_destino_id);
          }
          
          // Incluir apenas conex√µes entre equipamentos (n√£o keystones)
          const isEquipamentoSala = equipOrigem && equipDestino && 
                                   equipOrigem.sala_id == gridData.currentSalaId && 
                                   equipDestino.sala_id == gridData.currentSalaId;
          
          if (isEquipamentoSala) {
            console.log(`‚úÖ Conex√£o inclu√≠da: ${equipOrigem.nome} (ID:${equipOrigem.id}) ‚Üí ${equipDestino.nome} (ID:${equipDestino.id})`);
          }
          
          return isEquipamentoSala;
        });
        
        console.log('Conex√µes entre equipamentos filtradas:', conexoesEntreEquipamentos);
        console.log('Equipamentos da sala:', equipamentos.filter(e => e.sala_id == gridData.currentSalaId));
        
        console.log('Conex√µes entre equipamentos da sala:', conexoesEntreEquipamentos);
        
        for (const conexao of conexoesEntreEquipamentos) {
          const equipOrigem = equipamentos.find(e => e.id === conexao.equipamento_origem_id);
          
          // Para destino, verificar se √© patch panel ou equipamento
          let equipDestino = null;
          if (conexao.tipo_destino === 'patch_panel') {
            // Para patch panel, criar um objeto simulado
            equipDestino = {
              id: conexao.equipamento_destino_id,
              nome: conexao.equipamento_destino || 'Patch Panel',
              tipo: 'Patch Panel',
              sala_id: gridData.currentSalaId
            };
          } else {
            equipDestino = equipamentos.find(e => e.id === conexao.equipamento_destino_id);
          }
          
          if (equipOrigem && equipDestino) {
            console.log(`\n--- Processando conex√£o: ${equipOrigem.nome} ‚Üí ${equipDestino.nome} ---`);
            console.log(`  - Conex√£o ID: ${conexao.id}`);
            console.log(`  - Equipamento Origem: ${equipOrigem.nome} (ID: ${equipOrigem.id}, Sala: ${equipOrigem.sala_id})`);
            console.log(`  - Equipamento Destino: ${equipDestino.nome} (ID: ${equipDestino.id}, Sala: ${equipDestino.sala_id})`);
            console.log(`  - Porta Origem: ${conexao.porta_origem}`);
            console.log(`  - Porta Destino: ${conexao.porta_destino}`);
            console.log(`  - Tipo Cabo: ${conexao.tipo_cabo}`);
            console.log(`  - C√≥digo Cabo: ${conexao.codigo_cabo}`);
            
            const equipOrigemCell = findEquipmentCell(equipOrigem.nome);
            const equipDestinoCell = findEquipmentCell(equipDestino.nome);
            
            console.log(`üîç Buscando c√©lulas dos equipamentos:`);
            console.log(`  - Equipamento Origem: ${equipOrigem.nome}`);
            console.log(`  - C√©lula Origem encontrada:`, equipOrigemCell);
            console.log(`  - Equipamento Destino: ${equipDestino.nome}`);
            console.log(`  - C√©lula Destino encontrada:`, equipDestinoCell);
            
            if (equipOrigemCell && equipDestinoCell) {
              const fromRow = parseInt(equipOrigemCell.dataset.row);
              const fromCol = parseInt(equipOrigemCell.dataset.col);
              const toRow = parseInt(equipDestinoCell.dataset.row);
              const toCol = parseInt(equipDestinoCell.dataset.col);
              
              console.log(`üìç Coordenadas extra√≠das:`);
              console.log(`  - FROM (${equipOrigem.nome}): row=${fromRow}, col=${fromCol}`);
              console.log(`  - TO (${equipDestino.nome}): row=${toRow}, col=${toCol}`);
              console.log(`Posi√ß√µes: ${equipOrigem.nome}(${fromRow},${fromCol}) ‚Üí ${equipDestino.nome}(${toRow},${toCol})`);
              
              const connection = {
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                fromName: equipOrigem.nome,
                toName: equipDestino.nome,
                cableInfo: conexao.codigo_cabo || conexao.nome_cabo || `${conexao.tipo_cabo || 'Cabo'}-${conexao.id}`,
                id: `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${conexao.id || 'unknown'}`
              };
              
              console.log(`Connection object:`, connection);
              console.log(`  - FROM: ${equipOrigem.nome} (${fromRow},${fromCol})`);
              console.log(`  - TO: ${equipDestino.nome} (${toRow},${toCol})`);
              console.log(`  - Dire√ß√£o: ${equipOrigem.nome} ‚Üí ${equipDestino.nome}`);
              
              // Verificar se a conex√£o j√° existe antes de adicionar
              console.log(`üîç VERIFICA√á√ÉO ANTES DE ADICIONAR CONEX√ÉO:`);
              console.log(`  - Nova conex√£o: ${equipOrigem.nome} ‚Üí ${equipDestino.nome}`);
              console.log(`  - CableInfo: ${connection.cableInfo}`);
              console.log(`  - ID: ${connection.id}`);
              console.log(`  - Posi√ß√µes: (${fromRow},${fromCol}) ‚Üí (${toRow},${toCol})`);
              
              const connectionExistsResult = connectionExists(connection, gridData.connections);
              console.log(`  - Resultado da verifica√ß√£o: ${connectionExistsResult ? 'EXISTE' : 'N√ÉO EXISTE'}`);
              
              if (!connectionExistsResult) {
                gridData.connections.push(connection);
                console.log(`‚úÖ Conex√£o adicionada ao array: ${equipOrigem.nome} ‚Üí ${equipDestino.nome} (${connection.cableInfo})`);
                console.log(`  - Total de conex√µes no array: ${gridData.connections.length}`);
                console.log(`  - Array atualizado:`, gridData.connections);
                
                // Desenhar a conex√£o
                drawConnection(connection);
                console.log(`‚úÖ Conex√£o criada com sucesso: ${equipOrigem.nome} ‚Üí ${equipDestino.nome} (${connection.cableInfo})`);
              } else {
                console.log(`‚ö†Ô∏è Conex√£o duplicada ignorada: ${equipOrigem.nome} ‚Üí ${equipDestino.nome} (${connection.cableInfo})`);
                console.log(`  - Motivo: Posi√ß√£o e CableInfo id√™nticos`);
              }
            } else {
              console.warn(`‚ùå N√£o foi poss√≠vel criar conex√£o entre ${equipOrigem.nome} e ${equipDestino.nome}:`);
              if (!equipOrigemCell) console.warn(`  - C√©lula do equipamento origem ${equipOrigem.nome} n√£o encontrada`);
              if (!equipDestinoCell) console.warn(`  - C√©lula do equipamento destino ${equipDestino.nome} n√£o encontrada`);
            }
          }
        }
        
        console.log('=== FIM DAS CONEX√ïES ENTRE EQUIPAMENTOS DA SALA ===');
        
        // COMENTADO: Cria√ß√£o autom√°tica de conex√µes de teste removida para evitar conex√µes falsas
        // Se n√£o h√° conex√µes reais, o sistema deve mostrar apenas os equipamentos sem conex√µes
        if (conexoesEntreEquipamentos.length === 0) {
          console.log('‚ÑπÔ∏è Nenhuma conex√£o real encontrada na sala. Mostrando apenas equipamentos sem conex√µes.');
        }
        
        await Promise.all(connectionPromises);
        
        // Contar conex√µes de keystones criadas
        const keystoneConnections = keystonesEquipamentos.filter(keystone => {
          const equip = equipamentosComConexoes.find(e => e.id == keystone.equipamento_sala_id);
          return equip && findEquipmentCell(equip.nome) && findEquipmentCell(keystone.keystone);
        }).length;
        
        // Contar conex√µes entre equipamentos criadas
        const equipamentosConnections = conexoesEntreEquipamentos.length;
        
        // Contar equipamentos em estoque inclu√≠dos
        const equipamentosEstoqueIncluidos = equipamentosComConexoes.filter(e => e.sala_id === null).length;
        
        // Aguardar um pouco para garantir que os equipamentos foram posicionados
        setTimeout(() => {
          console.log('=== REDESENHANDO CONEX√ïES AP√ìS CARREGAMENTO DE DADOS REAIS ===');
          redrawAllConnections();
        }, 500);
        
        updateStatus(`Dados reais carregados: ${equipCount} equipamentos (${equipamentosEstoqueIncluidos} em estoque), ${keystoneCount} keystones, ${conexoes.length} conex√µes reais, ${keystoneConnections} conex√µes de keystones e ${equipamentosConnections} conex√µes entre equipamentos`);
        
      } catch (error) {
        console.error('Erro ao carregar dados reais:', error);
        updateStatus(`Erro ao carregar dados reais: ${error.message}`);
        alert(`Erro ao carregar dados reais: ${error.message}`);
      }
    }

    // Fun√ß√£o para buscar informa√ß√µes do keystone espec√≠fico para um patch panel
    async function getKeystoneInfoForPatchPanel(patchPanelId, patchPanelNome) {
      try {
        // Buscar portas do patch panel que est√£o conectadas
        const portasResponse = await fetch(`/patch-panels/${patchPanelId}/portas`);
        if (!portasResponse.ok) {
          console.warn('N√£o foi poss√≠vel carregar portas do patch panel');
          return { nome: patchPanelNome, porta: '' };
        }
        
        const portas = await portasResponse.json();
        
        // Encontrar a primeira porta conectada (ou usar a primeira dispon√≠vel)
        const portaConectada = portas.find(p => p.status === 'conectada') || portas[0];
        
        if (portaConectada) {
          // Criar nome do keystone baseado no patch panel e porta
          const prefixo = patchPanelNome.replace(/\s+/g, '').substring(0, 3).toLowerCase();
          const numeroPorta = portaConectada.numero_porta.toString().padStart(2, '0');
          const nomeKeystone = `${prefixo}--${numeroPorta}`;
          
          return {
            nome: nomeKeystone,
            porta: `Porta ${portaConectada.numero_porta}`
          };
        }
        
        return { nome: patchPanelNome, porta: '' };
      } catch (error) {
        console.error('Erro ao buscar keystone info:', error);
        return { nome: patchPanelNome, porta: '' };
      }
    }

    // Fun√ß√£o para encontrar imagem do equipamento usando o sistema de mapeamento inteligente
    async function findEquipmentImage(equipmentType, equipmentName = '', equipmentMarca = '', equipmentModelo = '') {
      try {
        console.log('üîç findEquipmentImage procurando por:', equipmentType, equipmentName, equipmentMarca, equipmentModelo);
        console.log('üîç Tipo em lowercase:', equipmentType ? equipmentType.toLowerCase() : 'null');
        console.log('üîç Nome em lowercase:', equipmentName ? equipmentName.toLowerCase() : 'null');
        console.log('üîç findEquipmentImageByType dispon√≠vel?', typeof findEquipmentImageByType);
        
        // Usar o novo sistema de mapeamento inteligente
        let mappedImage = null;
        if (typeof findEquipmentImageByType === 'function') {
          mappedImage = findEquipmentImageByType(equipmentType, equipmentName, equipmentMarca, equipmentModelo);
        } else {
          console.warn('‚ö†Ô∏è findEquipmentImageByType n√£o est√° dispon√≠vel, usando fallback');
        }
        
        if (mappedImage) {
          console.log('‚úÖ Imagem encontrada pelo mapeamento:', mappedImage);
          return mappedImage;
        } else {
          console.log('‚ùå Nenhuma imagem encontrada pelo mapeamento para:', equipmentType, equipmentName);
        }
        
        // Fallback: buscar na API de imagens se o mapeamento n√£o encontrou
        const response = await fetch('/api/equipamentos-imagens');
        const images = await response.json();
        console.log('üìã Imagens dispon√≠veis:', images);
        
        const type = equipmentType ? equipmentType.toLowerCase() : '';
        
        // Busca gen√©rica por tipo
        let matchingImage = images.find(img => {
          const imgName = img.split('/').pop().toLowerCase().replace(/\.[a-z]+$/i, '');
          return imgName === type || imgName.includes(type) || type.includes(imgName);
        });
        
        if (matchingImage) {
          console.log('‚úÖ Imagem encontrada por busca gen√©rica:', matchingImage);
          return matchingImage;
        }
        
        // Fallback simples para equipamentos comuns
        const fallbackImages = {
          'tv': '/static/img/equipamentos/tv-lg.png',
          'chromebox': '/static/img/equipamentos/pc-ctl.png',
          'fonte': '/static/img/equipamentos/poe-logitech.png',
          'microfone': '/static/img/equipamentos/microfone-logitech.png',
          'camera': '/static/img/equipamentos/camera-logitech.png',
          'speaker': '/static/img/equipamentos/speaker-logitech.png',
          'switch': '/static/img/equipamentos/switch-cisco.png',
          'hub': '/static/img/equipamentos/hub-logitech.png',
          'meetup': '/static/img/equipamentos/meetup-logitech.png',
          'tap': '/static/img/equipamentos/tap-logitech.png',
          'painel': '/static/img/equipamentos/painel-crestron.png'
        };
        
        for (const [key, img] of Object.entries(fallbackImages)) {
          if (type.includes(key)) {
            console.log('‚úÖ Usando fallback para', key, ':', img);
            return img;
          }
        }
        
        // Se ainda n√£o encontrou, usar a primeira imagem dispon√≠vel
        matchingImage = images[0];
        console.log('‚ö†Ô∏è Nenhuma imagem espec√≠fica encontrada, usando padr√£o:', matchingImage);
        return matchingImage;
        
      } catch (error) {
        console.error('Erro ao buscar imagem do equipamento:', error);
        return '/static/img/equipamentos/pc-ctl.png'; // Imagem padr√£o
      }
    }
    
    

    // Fun√ß√£o para calcular similaridade entre dois nomes
    function calculateNameSimilarity(name1, name2) {
      const words1 = name1.toLowerCase().split(/\s+/);
      const words2 = name2.toLowerCase().split(/\s+/);
      
      let totalSimilarity = 0;
      let comparisons = 0;
      
      for (const word1 of words1) {
        if (word1.length < 3) continue; // Ignorar palavras muito curtas
        
        let bestMatch = 0;
        for (const word2 of words2) {
          if (word2.length < 3) continue;
          
          // Calcular similaridade entre palavras
          let similarity = 0;
          if (word1 === word2) {
            similarity = 100;
          } else if (word1.includes(word2) || word2.includes(word1)) {
            similarity = Math.max(word1.length, word2.length) / Math.min(word1.length, word2.length) * 100;
          } else {
            // Calcular similaridade por caracteres comuns
            let commonChars = 0;
            for (let i = 0; i < Math.min(word1.length, word2.length); i++) {
              if (word1[i] === word2[i]) commonChars++;
            }
            similarity = (commonChars / Math.max(word1.length, word2.length)) * 100;
          }
          
          bestMatch = Math.max(bestMatch, similarity);
        }
        
        totalSimilarity += bestMatch;
        comparisons++;
      }
      
      return comparisons > 0 ? totalSimilarity / comparisons : 0;
    }

    // Fun√ß√£o para encontrar c√©lula onde est√° um equipamento
    function findEquipmentCell(equipmentName) {
      console.log(`findEquipmentCell procurando por: "${equipmentName}"`);
      
      const cells = document.querySelectorAll('.grid-cell.occupied');
      console.log(`C√©lulas ocupadas encontradas: ${cells.length}`);
      
      // Primeira tentativa: busca exata (mais espec√≠fica)
      for (const cell of cells) {
        const name = cell.querySelector('.name').textContent;
        const row = cell.dataset.row;
        const col = cell.dataset.col;
        
        if (name === equipmentName) {
          console.log(`‚úÖ EQUIPAMENTO ENCONTRADO - BUSCA EXATA na c√©lula (${row},${col})`);
          console.log(`  - Nome procurado: "${equipmentName}"`);
          console.log(`  - Nome encontrado: "${name}"`);
          console.log(`  - Posi√ß√£o: (${row},${col})`);
          return cell;
        }
      }
      
      // Segunda tentativa: busca por prefixo (para casos como "Receptor Microfone 01")
      for (const cell of cells) {
        const name = cell.querySelector('.name').textContent;
        const row = cell.dataset.row;
        const col = cell.dataset.col;
        
        // Verificar se o nome procurado √© um prefixo do nome encontrado
        if (equipmentName.toLowerCase().startsWith(name.toLowerCase()) || 
            name.toLowerCase().startsWith(equipmentName.toLowerCase())) {
          console.log(`‚úÖ EQUIPAMENTO ENCONTRADO - BUSCA POR PREFIXO na c√©lula (${row},${col})`);
          console.log(`  - Nome procurado: "${equipmentName}"`);
          console.log(`  - Nome encontrado: "${name}"`);
          console.log(`  - Posi√ß√£o: (${row},${col})`);
          return cell;
        }
      }
      
      // Terceira tentativa: busca por palavras-chave espec√≠ficas (mais restritiva)
      for (const cell of cells) {
        const name = cell.querySelector('.name').textContent;
        const row = cell.dataset.row;
        const col = cell.dataset.col;
        
        // Dividir nomes em palavras para compara√ß√£o mais precisa
        const searchWords = equipmentName.toLowerCase().split(/\s+/);
        const nameWords = name.toLowerCase().split(/\s+/);
        
        // Verificar se pelo menos 2 palavras-chave coincidem
        let matchingWords = 0;
        for (const searchWord of searchWords) {
          if (searchWord.length > 2) { // Ignorar palavras muito curtas
            for (const nameWord of nameWords) {
              if (nameWord.includes(searchWord) || searchWord.includes(nameWord)) {
                matchingWords++;
                break;
              }
            }
          }
        }
        
                  // Verifica√ß√£o adicional: evitar confus√£o entre equipamentos similares
          if (matchingWords >= 2) {
            // Verificar se n√£o h√° confus√£o entre "Microfone" e "Receptor Microfone"
            const isSearchingForReceptor = equipmentName.toLowerCase().includes('receptor');
            const isFoundMicrofone = name.toLowerCase().includes('microfone') && !name.toLowerCase().includes('receptor');
            
            if (isSearchingForReceptor && isFoundMicrofone) {
              console.log(`‚ö†Ô∏è CONFLITO DETECTADO: Procurando por receptor mas encontrou microfone`);
              console.log(`  - Nome procurado: "${equipmentName}" (cont√©m 'receptor')`);
              console.log(`  - Nome encontrado: "${name}" (cont√©m 'microfone' mas n√£o 'receptor')`);
              console.log(`  - Continuando busca...`);
              continue; // Pular esta c√©lula e continuar procurando
            }
            
            // Verificar se n√£o h√° confus√£o entre "Antena" e outros equipamentos
            const isSearchingForAntena = equipmentName.toLowerCase().includes('antena');
            const isFoundAntena = name.toLowerCase().includes('antena');
            
            if (isSearchingForAntena && !isFoundAntena) {
              console.log(`‚ö†Ô∏è CONFLITO DETECTADO: Procurando por antena mas encontrou outro equipamento`);
              console.log(`  - Nome procurado: "${equipmentName}" (cont√©m 'antena')`);
              console.log(`  - Nome encontrado: "${name}" (n√£o cont√©m 'antena')`);
              console.log(`  - Continuando busca...`);
              continue; // Pular esta c√©lula e continuar procurando
            }
            
            console.log(`‚úÖ EQUIPAMENTO ENCONTRADO - BUSCA POR PALAVRAS-CHAVE na c√©lula (${row},${col})`);
            console.log(`  - Nome procurado: "${equipmentName}"`);
            console.log(`  - Nome encontrado: "${name}"`);
            console.log(`  - Palavras coincidentes: ${matchingWords}`);
            console.log(`  - Posi√ß√£o: (${row},${col})`);
            return cell;
          }
      }
      
      // Quarta tentativa: busca gen√©rica (fallback) - COM VERIFICA√á√ïES ADICIONAIS
      for (const cell of cells) {
        const name = cell.querySelector('.name').textContent;
        const row = cell.dataset.row;
        const col = cell.dataset.col;
        console.log(`Verificando c√©lula (${row},${col}) com nome: "${name}"`);
        
        if (name.toLowerCase().includes(equipmentName.toLowerCase()) || 
            equipmentName.toLowerCase().includes(name.toLowerCase())) {
          
          // Verifica√ß√µes de seguran√ßa para evitar confus√µes
          const isSearchingForReceptor = equipmentName.toLowerCase().includes('receptor');
          const isFoundMicrofone = name.toLowerCase().includes('microfone') && !name.toLowerCase().includes('receptor');
          const isSearchingForAntena = equipmentName.toLowerCase().includes('antena');
          const isFoundAntena = name.toLowerCase().includes('antena');
          
          // Se est√° procurando por receptor, n√£o aceitar microfone
          if (isSearchingForReceptor && isFoundMicrofone) {
            console.log(`‚ùå CONFLITO CR√çTICO: Procurando por receptor mas encontrou microfone`);
            console.log(`  - Nome procurado: "${equipmentName}" (cont√©m 'receptor')`);
            console.log(`  - Nome encontrado: "${name}" (cont√©m 'microfone' mas n√£o 'receptor')`);
            console.log(`  - Rejeitando esta c√©lula`);
            continue;
          }
          
          // Se est√° procurando por antena, n√£o aceitar outros equipamentos
          if (isSearchingForAntena && !isFoundAntena) {
            console.log(`‚ùå CONFLITO CR√çTICO: Procurando por antena mas encontrou outro equipamento`);
            console.log(`  - Nome procurado: "${equipmentName}" (cont√©m 'antena')`);
            console.log(`  - Nome encontrado: "${name}" (n√£o cont√©m 'antena')`);
            console.log(`  - Rejeitando esta c√©lula`);
            continue;
          }
          
          // Verifica√ß√£o final: calcular similaridade entre nomes
          const similarity = calculateNameSimilarity(equipmentName, name);
          console.log(`  - Similaridade entre nomes: ${similarity.toFixed(2)}%`);
          
          // Se a similaridade for muito baixa, rejeitar
          if (similarity < 60) {
            console.log(`‚ùå SIMILARIDADE MUITO BAIXA: Rejeitando c√©lula`);
            console.log(`  - Nome procurado: "${equipmentName}"`);
            console.log(`  - Nome encontrado: "${name}"`);
            console.log(`  - Similaridade: ${similarity.toFixed(2)}% < 60%`);
            continue;
          }
          
          console.log(`‚ö†Ô∏è EQUIPAMENTO ENCONTRADO - BUSCA GEN√âRICA na c√©lula (${row},${col})`);
          console.log(`  - Nome procurado: "${equipmentName}"`);
          console.log(`  - Nome encontrado: "${name}"`);
          console.log(`  - Posi√ß√£o: (${row},${col})`);
          console.log(`  - Similaridade: ${similarity.toFixed(2)}%`);
          console.log(`  - ‚ö†Ô∏è ATEN√á√ÉO: Esta busca pode n√£o ser precisa!`);
          return cell;
        }
      }
      
      console.warn(`‚ùå Equipamento "${equipmentName}" n√£o encontrado`);
      return null;
    }

    // Fun√ß√£o para carregar dados reais com modal de confirma√ß√£o
    function showLoadRealDataModal() {
      if (!gridData.currentSalaId) {
        alert('Nenhuma sala selecionada! Selecione uma sala primeiro.');
        return;
      }

      const confirmLoad = confirm(
        'Carregar dados reais da sala?\n\n' +
        'Isso ir√°:\n' +
        '‚Ä¢ Limpar o layout atual\n' +
        '‚Ä¢ Buscar equipamentos reais da sala\n' +
        '‚Ä¢ Buscar conex√µes reais da sala\n' +
        '‚Ä¢ Posicionar tudo automaticamente\n\n' +
        'Deseja continuar?'
      );

      if (confirmLoad) {
        loadRealData();
      }
    }



    btnPlaceMode.addEventListener('click', () => {
      gridData.connectionMode = false;
      gridData.removeMode = false;
      gridData.textMode = false;
      gridData.connectionStart = null;
      btnPlaceMode.classList.add('active');
      btnConnectMode.classList.remove('active');
      btnRemoveMode.classList.remove('active');
      btnTextMode.classList.remove('active');
      
      // Limpa sele√ß√µes
      document.querySelectorAll('.grid-cell.selected, .grid-cell.connectable, .grid-cell.removable').forEach(cell => {
        cell.classList.remove('selected', 'connectable', 'removable');
      });
      
      // Remove classe remove-mode do container
      gridContainer.classList.remove('remove-mode');
      
      // Habilitar sele√ß√£o de equipamentos
      equipmentSelect.disabled = false;
      
      updateStatus('Modo: Posicionar equipamentos');
    });

    btnConnectMode.addEventListener('click', () => {
      gridData.connectionMode = true;
      gridData.removeMode = false;
      gridData.textMode = false;
      btnConnectMode.classList.add('active');
      btnPlaceMode.classList.remove('active');
      btnRemoveMode.classList.remove('active');
      btnTextMode.classList.remove('active');
      
      // Limpa sele√ß√µes de remo√ß√£o
      document.querySelectorAll('.grid-cell.removable').forEach(cell => {
        cell.classList.remove('removable');
      });
      
      // Remove classe remove-mode do container
      gridContainer.classList.remove('remove-mode');
      
      // Limpar sele√ß√£o de equipamento no modo conex√£o
      equipmentSelect.value = '';
      equipmentPreview.classList.add('hidden');
      gridData.selectedEquipment = null;
      
      // Desabilitar sele√ß√£o de equipamentos
      equipmentSelect.disabled = true;
      
      updateStatus('Modo: Conectar equipamentos');
    });

    btnRemoveMode.addEventListener('click', () => {
      gridData.removeMode = true;
      gridData.connectionMode = false;
      gridData.textMode = false;
      gridData.connectionStart = null;
      btnRemoveMode.classList.add('active');
      btnPlaceMode.classList.remove('active');
      btnConnectMode.classList.remove('active');
      btnTextMode.classList.remove('active');
      
      // Limpa sele√ß√µes de conex√£o
      document.querySelectorAll('.grid-cell.selected, .grid-cell.connectable').forEach(cell => {
        cell.classList.remove('selected', 'connectable');
      });
      
      // Adiciona classe remove-mode ao container
      gridContainer.classList.add('remove-mode');
      
      // Limpar sele√ß√£o de equipamento no modo remo√ß√£o
      equipmentSelect.value = '';
      equipmentPreview.classList.add('hidden');
      gridData.selectedEquipment = null;
      
      // Desabilitar sele√ß√£o de equipamentos
      equipmentSelect.disabled = true;
      
      updateStatus('Modo: Remover equipamentos (clique nos equipamentos para remover)');
    });

    btnTextMode.addEventListener('click', () => {
      gridData.textMode = true;
      gridData.connectionMode = false;
      gridData.removeMode = false;
      gridData.connectionStart = null;
      btnTextMode.classList.add('active');
      btnPlaceMode.classList.remove('active');
      btnConnectMode.classList.remove('active');
      btnRemoveMode.classList.remove('active');
      
      // Limpa sele√ß√µes de outros modos
      document.querySelectorAll('.grid-cell.selected, .grid-cell.connectable, .grid-cell.removable').forEach(cell => {
        cell.classList.remove('selected', 'connectable', 'removable');
      });
      
      // Remove classe remove-mode do container
      gridContainer.classList.remove('remove-mode');
      
      // Limpar sele√ß√£o de equipamento no modo texto
      equipmentSelect.value = '';
      equipmentPreview.classList.add('hidden');
      gridData.selectedEquipment = null;
      
      // Desabilitar sele√ß√£o de equipamentos
      equipmentSelect.disabled = true;
      
      updateStatus('Modo: Adicionar/Editar texto (clique em uma c√©lula para adicionar texto)');
    });

    btnLoadRealData.addEventListener('click', showLoadRealDataModal);

    // Modo distribu√≠do sempre ativo - sem necessidade de altern√¢ncia
    console.log('‚úÖ Modo distribu√≠do sempre ativo em conexoes-equipamentos.html');


    


    btnSair.addEventListener('click', () => {
      if (confirm('Tem certeza que deseja voltar √† sele√ß√£o de layout? As altera√ß√µes n√£o salvas ser√£o perdidas.')) {
        // Limpar dados atuais
        gridData.currentSalaId = null;
        gridData.connections = [];
        gridData.connectionStart = null;
        gridData.selectedEquipment = null;
        
        // Limpar grade sem confirma√ß√£o
        clearAllWithoutConfirmation();
        
        // Mostrar modal inicial
        showInitialModal();
      }
    });

    btnSave.addEventListener('click', saveLayout);
    btnClear.addEventListener('click', clearAll);
    
    btnCancelSala.addEventListener('click', () => {
      salaModal.style.display = 'none';
    });

    // Event listeners do modal inicial
    btnBack.addEventListener('click', () => {
      prevStep();
    });

    btnContinue.addEventListener('click', () => {
      const salaId = salaSelectInitial.value;
      if (!salaId) {
        alert('Selecione uma sala!');
        return;
      }
      
      const option = salaSelectInitial.options[salaSelectInitial.selectedIndex];
      const sala = JSON.parse(option.dataset.sala);
      modalState.selectedSala = sala;
      
      showSalaInfo(sala);
      updateLayoutStatus(salaId);
      nextStep();
      
      // Configurar informa√ß√µes de confirma√ß√£o
      if (modalState.layoutExists) {
        confirmInfo.innerHTML = `
          <h4>Editar Layout Existente</h4>
          <p><strong>Sala:</strong> ${sala.nome || `Sala ${sala.id}`}</p>
          <p><strong>A√ß√£o:</strong> Editar layout existente</p>
          <p style="color: #28a745; font-size: 12px;">‚úÖ Layout encontrado e ser√° carregado.</p>
        `;
      } else {
        confirmInfo.innerHTML = `
          <h4>Criar Novo Layout</h4>
          <p><strong>Sala:</strong> ${sala.nome || `Sala ${sala.id}`}</p>
          <p><strong>A√ß√£o:</strong> Criar novo layout</p>
          <p style="color: #ffc107; font-size: 12px;">üÜï Nenhum layout encontrado. Ser√° criado um novo.</p>
        `;
      }
    });

    btnConfirm.addEventListener('click', confirmAction);
    btnCancel.addEventListener('click', () => {
      fetch('/perfil').then(resp => resp.json()).then(perfil => {
        if (perfil.nivel === 'admin') {
          window.location.href = 'config-admin.html';
        } else if (perfil.nivel === 'tecnico') {
          window.location.href = 'config-tecnico.html';
        } else {
          window.location.href = 'config-usuario.html';
        }
      });
    });

    // Event listener para mudan√ßa na sele√ß√£o de sala
    salaSelectInitial.addEventListener('change', async () => {
      const salaId = salaSelectInitial.value;
      if (salaId) {
        const option = salaSelectInitial.options[salaSelectInitial.selectedIndex];
        const sala = JSON.parse(option.dataset.sala);
        showSalaInfo(sala);
        await updateLayoutStatus(salaId);
      } else {
        salaInfo.style.display = 'none';
      }
    });

    // Inicializa√ß√£o
    document.addEventListener('DOMContentLoaded', () => {
      loadEquipment();
      createGrid();
      
      // Modo distribu√≠do sempre ativo - sem necessidade de inicializa√ß√£o de bot√£o
      
      // Verificar se h√° sala_id na URL
      const params = new URLSearchParams(window.location.search);
      const salaId = params.get('sala_id');
      
      if (salaId) {
        // Se h√° sala_id na URL, carrega diretamente
        gridData.currentSalaId = salaId;
        loadLayout(salaId);
      } else {
        // Se n√£o h√° sala_id, mostra modal inicial
        showInitialModal();
      }
    });

    // Fun√ß√£o para buscar keystones dos equipamentos da sala
    async function loadKeystonesFromEquipamentos(equipamentos) {
      try {
        const keystones = [];
        
        // Buscar todos os patch panels
        const patchPanelsResponse = await fetch('/patch-panels');
        if (!patchPanelsResponse.ok) {
          console.warn('N√£o foi poss√≠vel carregar patch panels');
          return [];
        }
        
        const patchPanels = await patchPanelsResponse.json();
        console.log('Patch panels encontrados:', patchPanels);
        
        // Para cada patch panel, buscar suas portas
        for (const patchPanel of patchPanels) {
          const portasResponse = await fetch(`/patch-panels/${patchPanel.id}/portas`);
          if (!portasResponse.ok) {
            console.warn(`N√£o foi poss√≠vel carregar portas do patch panel ${patchPanel.id}`);
            continue;
          }
          
          const portas = await portasResponse.json();
          console.log(`Portas do patch panel ${patchPanel.id}:`, portas);
          
          // Verificar se h√° uma API espec√≠fica para buscar detalhes das portas
          if (portas.length > 0) {
            console.log(`Verificando se h√° API espec√≠fica para detalhes da porta ${portas[0].id}`);
            try {
              const portaDetalhesResponse = await fetch(`/patch-panels/${patchPanel.id}/portas/${portas[0].id}`);
              if (portaDetalhesResponse.ok) {
                const portaDetalhes = await portaDetalhesResponse.json();
                console.log(`Detalhes da porta ${portas[0].id}:`, portaDetalhes);
                console.log(`Campos dispon√≠veis nos detalhes:`, Object.keys(portaDetalhes));
              }
            } catch (error) {
              console.log(`API de detalhes da porta n√£o dispon√≠vel:`, error.message);
            }
          }
          
          // Filtrar apenas portas ocupadas que t√™m equipamentos da sala atual
          const portasSala = portas.filter(porta => {
            const isOcupada = porta.status === 'ocupada';
            const isSalaCorreta = porta.equipamento_sala_id == gridData.currentSalaId;
            
            console.log(`Porta ${porta.id}: status=${porta.status}, equipamento_sala_id=${porta.equipamento_sala_id}, sala_atual=${gridData.currentSalaId}, ocupada=${isOcupada}, sala_correta=${isSalaCorreta}`);
            console.log(`  - Detalhes da porta:`, porta);
            console.log(`  - Campos dispon√≠veis na porta:`, Object.keys(porta));
            console.log(`  - Valores dos campos relacionados a cabo:`);
            console.log(`    * codigo_cabo: ${porta.codigo_cabo}`);
            console.log(`    * codigo: ${porta.codigo}`);
            console.log(`    * cable_code: ${porta.cable_code}`);
            console.log(`    * cabo: ${porta.cabo}`);
            console.log(`    * ethernet: ${porta.ethernet}`);
            console.log(`    * nome_cabo: ${porta.nome_cabo}`);
            console.log(`    * identificacao_cabo: ${porta.identificacao_cabo}`);
            
            return isOcupada && isSalaCorreta;
          });
          
          console.log(`Portas da sala ${gridData.currentSalaId} no patch panel ${patchPanel.id}:`, portasSala);
          
          // Adicionar keystones das portas ocupadas
          portasSala.forEach(async (porta) => {
            const keystone = `${porta.prefixo_keystone}-${porta.numero_porta.toString().padStart(4, '0')}`;
            
            // Tentar buscar informa√ß√µes completas da porta
            let portaCompleta = porta;
            try {
              const portaDetalhesResponse = await fetch(`/patch-panels/${patchPanel.id}/portas/${porta.id}`);
              if (portaDetalhesResponse.ok) {
                portaCompleta = await portaDetalhesResponse.json();
                console.log(`Informa√ß√µes completas da porta ${porta.id}:`, portaCompleta);
              }
            } catch (error) {
              console.log(`N√£o foi poss√≠vel buscar detalhes da porta ${porta.id}:`, error.message);
            }
            
            // Buscar c√≥digo do cabo em diferentes campos poss√≠veis
            let codigoCabo = null;
            
            // Tentar todos os campos poss√≠veis em ordem de prioridade
            if (portaCompleta.codigo_cabo) codigoCabo = portaCompleta.codigo_cabo;
            else if (portaCompleta.codigo) codigoCabo = portaCompleta.codigo;
            else if (portaCompleta.cable_code) codigoCabo = portaCompleta.cable_code;
            else if (portaCompleta.cabo) codigoCabo = portaCompleta.cabo;
            else if (portaCompleta.ethernet) codigoCabo = portaCompleta.ethernet;
            else if (portaCompleta.nome_cabo) codigoCabo = portaCompleta.nome_cabo;
            else if (portaCompleta.identificacao_cabo) codigoCabo = portaCompleta.identificacao_cabo;
            else if (portaCompleta.cable_name) codigoCabo = portaCompleta.cable_name;
            else if (portaCompleta.cable_id) codigoCabo = portaCompleta.cable_id;
            else if (portaCompleta.etiqueta) codigoCabo = portaCompleta.etiqueta;
            else if (portaCompleta.label) codigoCabo = portaCompleta.label;
            
            // Se n√£o encontrou nenhum, usar um c√≥digo baseado no patch panel
            if (!codigoCabo) {
              const patchPanelPrefix = patchPanel.nome ? patchPanel.nome.replace(/\s+/g, '').substring(0, 3) : 'PP';
              codigoCabo = `${patchPanelPrefix}-${porta.numero_porta.toString().padStart(3, '0')}`;
            }
            
            console.log(`Keystone ${keystone}: c√≥digo do cabo encontrado: "${codigoCabo}"`);
            console.log(`  - Campo usado: ${portaCompleta.codigo_cabo ? 'codigo_cabo' : portaCompleta.codigo ? 'codigo' : portaCompleta.cable_code ? 'cable_code' : portaCompleta.cabo ? 'cabo' : portaCompleta.ethernet ? 'ethernet' : portaCompleta.nome_cabo ? 'nome_cabo' : portaCompleta.identificacao_cabo ? 'identificacao_cabo' : portaCompleta.cable_name ? 'cable_name' : portaCompleta.cable_id ? 'cable_id' : portaCompleta.etiqueta ? 'etiqueta' : portaCompleta.label ? 'label' : 'gerado automaticamente'}`);
            
            keystones.push({
              keystone: keystone,
              patch_panel_id: patchPanel.id,
              patch_panel_nome: patchPanel.nome,
              porta_id: porta.id,
              equipamento_sala_id: porta.equipamento_sala_id,
              porta_original: portaCompleta, // Incluir todos os dados da porta
              equipamento_nome: portaCompleta.equipamento_nome || null, // Se existir
              equipamento_tipo: portaCompleta.equipamento_tipo || null, // Se existir
              codigo_cabo: codigoCabo // C√≥digo do cabo encontrado
            });
          });
        }
        
        console.log(`Keystones encontrados nos equipamentos da sala:`, keystones);
        console.log('Tipo de keystones:', typeof keystones);
        console.log('√â array?', Array.isArray(keystones));
        console.log('Comprimento:', keystones ? keystones.length : 'null/undefined');
        return keystones;
        
      } catch (error) {
        console.error('Erro ao buscar keystones dos equipamentos:', error);
        return [];
      }
    }

    // Fun√ß√£o para lidar com clique para texto - otimizada
    function handleTextClick(cell, row, col) {
      if (cell.classList.contains('text-occupied')) {
        // Se j√° tem texto, permite editar
        const textElement = cell.querySelector('.text-element');
        if (textElement) {
          editTextElement(textElement);
        }
      } else {
        // Se n√£o tem texto, permite adicionar
        addTextElement(cell, row, col);
      }
    }

    // Fun√ß√£o para adicionar elemento de texto
    function addTextElement(cell, row, col) {
      const text = prompt('Digite o texto da observa√ß√£o:');
      if (text === null || text.trim() === '') {
        return;
      }
      
      const textContent = text.trim();
      
      cell.innerHTML = `
        <div class="text-element">
          ${textContent}
        </div>
      `;
      
      cell.classList.add('text-occupied');
      
      // Torna o texto arrast√°vel
      const textElement = cell.querySelector('.text-element');
      makeTextDraggable(textElement);
      
      updateStatus(`Texto adicionado: "${textContent}"`);
    }

    // Fun√ß√£o para editar elemento de texto
    function editTextElement(textElement) {
      const currentText = textElement.textContent.trim();
      const newText = prompt('Editar texto:', currentText);
      
      if (newText === null) {
        return;
      }
      
      const textContent = newText.trim();
      if (textContent === '') {
        // Se o texto ficou vazio, remover o elemento
        const cell = textElement.closest('.grid-cell');
        if (cell) {
          cell.innerHTML = '';
          cell.classList.remove('text-occupied');
          updateStatus('Texto removido');
        }
        return;
      }
      
      textElement.textContent = textContent;
      textElement.classList.add('editing');
      
      // Remove a classe de edi√ß√£o ap√≥s um tempo
      setTimeout(() => {
        textElement.classList.remove('editing');
      }, 1000);
      
      updateStatus(`Texto editado: "${textContent}"`);
    }

    // Fun√ß√£o para tornar texto arrast√°vel
    function makeTextDraggable(textElement) {
      textElement.draggable = true;
      
      textElement.addEventListener('dragstart', (e) => {
        if (gridData.connectionMode || gridData.removeMode) {
          e.preventDefault();
          return;
        }
        
        gridData.dragState.isDragging = true;
        gridData.dragState.draggedElement = textElement;
        gridData.dragState.originalCell = textElement.closest('.grid-cell');
        gridData.dragState.originalRow = parseInt(gridData.dragState.originalCell.dataset.row);
        gridData.dragState.originalCol = parseInt(gridData.dragState.originalCell.dataset.col);
        gridData.dragState.dragStartTime = Date.now();
        
        textElement.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', 'text');
        
        console.log('Iniciando arrasto de texto:', gridData.dragState.originalRow, gridData.dragState.originalCol);
      });
      
      textElement.addEventListener('dragend', (e) => {
        gridData.dragState.isDragging = false;
        gridData.dragState.draggedElement = null;
        gridData.dragState.originalCell = null;
        gridData.dragState.originalRow = null;
        gridData.dragState.originalCol = null;
        gridData.dragState.dragStartTime = null;
        
        textElement.classList.remove('dragging');
        
        // Remove destaque de todas as c√©lulas
        document.querySelectorAll('.grid-cell.drag-over').forEach(cell => {
          cell.classList.remove('drag-over');
        });
        
        console.log('Finalizando arrasto de texto');
      });
    }

  </script>
</body>

</html>